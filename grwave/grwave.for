C***********************************************************************
C*                                                                     *
C*   GRWAVE (RELAESE 2   18/02/1985  ).                                *
C*   COPYRIGHT (C)   GEC PLC  1985.                                    *
C*                                                                     *
C***********************************************************************
C
C================================================================
C=         MODIFIED FOR MICROSOFT FORTRAN VERSION 4.0           = 
C=         FOR MS-DOS PERSONAL COMPUTERS                        =
C=          July 1988/10DEC88-jfc                               =
C=          CCIR United States Study Group 5                    =
C=          Dr. John F. Cavanagh                                =   
C=          Ms. Sheila A. Thurston                              =
C=          Naval Surface Warfare Center                        =
C=          Code F405                                           =
C=          Dahlgren, VA 22448-5000                             =
C================================================================
C
      PROGRAM ROTHRM
C     ROTHRM=STEVE ROTHERAM
C     FORTRAN 77
C IDEBUG CONTROLS THE AMOUNT OF OUTPUT GIVEN:IDEBUG=0 FOR PRINCIPAL IN
C-PUT QUANTITIES AND RESULTS,1=FOR SOME INTERMEDIATE QUANTITIES AND 2
C FOR COMPREHENSIVE OUTPUT FOR DIAGNOSTIC PURPOSES.
C IPOLRN=1 FOR VERTICAL,2 FOR HORIZONTAL POLARISATION.
C FREQ IS THE FREQUENCY IN MHZ.
C EPSLON IS THE RELATIVE DIELECTRIC CONSTANT OF THE EARTH.
C SIGMA IS THE CONDUCTIVITY OF THE EARTH IN SEIMENS/METRE.
C DMIN IS THE MINIMUM RANGE IN KM.
C DMAX IS THE MAXIMUM RANGE IN KM.
C DSTEP IS ADDED TO (LOGLIN=0) OR MULTIPLIED (LOGLIN=1) THE RANGE AT
C EACH STEP IN FLATX3 AND GEOMOP.WHILE IN DSTEP IS SUBTRACTED TO (LOGLIN
C =0) OR DIVIDED (LOGLIN=1) THE RANGE AT EACH STEP IN RESIDH.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER * 8 KEY, ITEST ,KEYGO
      PARAMETER (NINTS=5,NREALS=8,N1REAL=NINTS+1,NVALS=NINTS+NREALS)
      PARAMETER (NKEYS=15)
      DIMENSION KEY(NKEYS),HRR(20),HTT(20)
      COMMON/INTGER/IDEBUG,IPOLRN,LOGLIN,JHT,IG
      COMMON/REAL/FREQ,EPSLON,SIGMA,DMIN,DSTEP,DMAX,ANS, HSCALE
      DIMENSION IAR(NINTS)
      DIMENSION RAR(NREALS)
      EQUIVALENCE (IAR(1),IDEBUG)
      EQUIVALENCE (RAR(1),FREQ)
      DATA KEYGO/'GO'/
      DATA KEY/'IDEBUG','IPOLRN','LOGLIN','JHT','IG', 'FREQ','EPSLON',
     1 'SIGMA','DMIN','DSTEP','DMAX','ANS', 'HSCALE','HRR','HTT'/
C
C**THE FOLLOWING ARE DEFAULT VALUES*****
C
C     CALL ERRORS ***Marconi mainframe routine***
      ANS=315.0D0
      HSCALE=7.35D0
      LOGLIN=0
      IPOLRN=1
      IDEBUG=0
      IG=0
      FREQ = 1.0D0
C
c*****EPSLON=RELATIVE PERMITTIVITY.
C*****SIGMA=CONDUCTIVITY OF EARTH IN SIEMENS/METRE
      EPSLON= 70.0D0
      SIGMA= 5.0 D0
      DMIN= 10.0 D0
      DSTEP=10.0 D0
      DMAX= 200.0 D0
C
C***HEIGHTS ARE IN METRES AND RANGES ARE IN KILOMETRES.
C
      JR=1
      JT=1
      JHT=1
      HRR(1)= 100.0D0
      HTT(1)= 50.0D0
      IERRCT=0
C
C READ A WORD
C
   10 CALL WORDN(ITEST,IERR)
C
C EOF OR NUMBER READ.....
C
      IF(IERR.EQ.1)GOTO 60
      IF(IERR.EQ.2)GOTO 100
C
C LOOK IT UP
C
      IF(ITEST.EQ.'HRR')GOTO 20
      IF(ITEST.EQ.'HTT')GOTO 30
      IF(ITEST.EQ.'GO')GOTO 90
      IF(ITEST.EQ.'STOP') GOTO 100
      GOTO 40
C
   20 CALL RDDLST(HRR,20,NLIST,IRET,.TRUE.)
      JR=NLIST
C     WRITE(6,*)(HRR(I),I=1,JR)
      IF(IRET.NE.0)GOTO 80
      GOTO 10
   30 CALL RDDLST(HTT,20,NLIST,IRET,.TRUE.)
      JT=NLIST
C     WRITE(6,*)(HTT(I),I=1,JT)
      IF(IRET.NE.0)GOTO 80
      GOTO 10
C
   40 DO 50 M=1,NKEYS
        IF(ITEST.EQ.KEY(M))GOTO 70
   50   CONTINUE
C
C  NOT IN TABLE
C
      WRITE(6,1000)ITEST
      CALL WRBUFF
 1000 FORMAT('0*** UNRECOGNISED KEY',2X,A8,'IN INPUT.RECORD READS:')
      IERRCT=IERRCT+1
      GOTO 10
C
C  SKIP MISPLACED NUMBER
C
   60 CALL READDP(VALUE,IERR)
      WRITE(6,2000)VALUE
 2000 FORMAT('0***MISPLACED NUMBER',1PG10.3,'IN INPUT.RECORD READS:')
      CALL WRBUFF
      IERRCT=IERRCT+1
      GOTO 10
C
C LEGEL KEY -IS IT 'GO'?
C
   70 IF(IERRCT.GT.0)GOTO 10
      IF(M.LE.NINTS)THEN
      CALL RDINT(IAR(M),IERR)
C     PRINT*,'IAR(M)',IAR(M),'M',M
      ELSE
      CALL READDP(RAR(M-NINTS),IERR)
C     PRINT*,'RAR(M-NINTS)',RAR(M-NINTS) ,'M-NINTS',M,NINTS
      END IF
      IF(IERR.NE.0)GOTO 80
      GOTO 10
C
C SOMETHING WRONG WITH THE NUMBER
C
   80 WRITE(6,3000)ITEST
 3000 FORMAT('0***NUMBER IN ERROR AFTER KEY ',A4,'.RECORD READS:')
      CALL WRBUFF
      IERRCT=IERRCT+1
      GOTO 10
C
C  'GO'....................
C
C**** CAN'T HAVE DMIN=0.0 BECAUSE THEN A FUNCTION IS DIVIDED BY ZERO.
C**** BESIDES THE THEORY IS ONLY VALID FOR DMIN GREATER
C**** THAN THE WAVELENGHT.SO WRITE
   90 WAVEL=3.0E-1/FREQ
      IF(DMIN.LE.2.0D0*WAVEL)DMIN=2.0D0*WAVEL
C     PRINT*,'DMIN',DMIN
C
      CALL GRWAVE(IDEBUG,IG,IPOLRN,LOGLIN,FREQ,EPSLON,SIGMA,DMIN,DSTEP,
     1 DMAX,JR,JT,JHT,HRR,HTT,ANS,HSCALE)
C
      GOTO 10

  100 IF(IERRCT == 0) stop

      WRITE(6,4000)IERRCT
 4000 FORMAT('***',I8,'ERRORS FOUND IN INPUT -PROGRAM NOT RUN')
      Error Stop

      END Program
C***********************************************************************
C*                                                                     *
C*  GRWAVE (RELEASE 2 18/2/1985)                                       *
C*  COPYRIGHT (C)    GEC PLC   1985  .                                 *
C*                                                                     *
C***********************************************************************
      SUBROUTINE GRWAVE(IBUG,IG,IPLRN,LOGLIN,FREQCY,EPSLON,SIGMA,DMIN,
     1 DSTEP,DMAX,JR,JT,JHT,HRR,HTT,ANS,HSCALE)
      IMPLICIT REAL*8 (A-H,O-Z)
      COMPLEX*16 NES,PSI0,AKI
      REAL*8 DA(100),EDBA(100),TL(100),HR(20),HT(20),DM(20,20),HRR(20),
     1 HTT(20)
      COMMON /BUGGER/M,IDEBUG,AK,AK2,AKI /EARTH/DEL,SC,D1P0/
     1  BROCK/HTU(20),HRU(20),FREQ,TLC,IPOLRN
C
C COMMON /EARTH IS REQUIRED IN SUBROUTINE PFUNCS
C****IF IG=-1 OR 0 THE FAR FIELD IS COMPUTED.IF IG=0 OR 1 THE NEAR FIELD
C****IS COMPUTED.
      IDEBUG=IBUG
      IPOLRN=IPLRN
      FREQ=FREQCY
      WRITE(6,500)
 500  FORMAT(' ','******GRWAVE  (RELEASE 2 AT 23/10/1985 )********'
     2,/' ','*****COPYRIGHT  (C)   GEC   PLC   1985   *********'
     3,/' CCIR Personal Computer Version 1989 Study Group 5 IWP5/1')
      WRITE(6,1000)
 1000 FORMAT(' ',/' ','GRWAVE COMPUTES FIELD STRENGTH-DISTANCE VARIATION
     1S',/' FOR A HOMOGENEOUS CURVED EARTH WITH EXPONENTIALLY',
     2/' DECREASING REFRACTIVE INDEX')
C **********
C PROF SETS UP THE PARAMETERS FOR AN EXPONENTIAL ATMOSPHERE.
      CALL PROF(ANS,HSCALE,DEL,SC,D1P0)
      DELSUB=DEL
      IF(IDEBUG.GE.1)PRINT*,'IG',IG,'IDEBUG',IDEBUG,'IPOLRN',IPOLRN,
     1 'FREQ',FREQ,'EPSLON',EPSLON,'SIGMA',SIGMA,'DMIN',DMIN,'DSTEP',
     2 DSTEP,'DMAX',DMAX,'JR',JR,'JT',JT,'JHT',JHT, 'GRWAVE-198'
      IF(IPOLRN.EQ.1.AND.IDEBUG.GE.1)WRITE(6,2000)
 2000 FORMAT('1VERTICAL POLARISATION' ' GRWAVE-201')
      IF(IPOLRN.EQ.2.AND.IDEBUG.GE.1)WRITE(6,3000)
 3000 FORMAT('1HORIZONTAL POLARISATION' ' GRWAVE-203')
      IF(IDEBUG.GE.1)WRITE(6,4000)FREQ,EPSLON,SIGMA
 4000 FORMAT(' FREQUENCY=',E15.7,'  MHZ'/' GROUND CONSTANTS      EPSLON=
     1',E15.7,'      SIGMA=',E15.7,'  S/M' ' GRWAVE-205')
      IF(IDEBUG.EQ.0)WRITE(6,5000)EPSLON,SIGMA
 5000 FORMAT(/21X,'GROUND CONSTANTS'/25X,'RELATIVE PERMITTIVITY =',F10.3
     1 /25X,'CONDUCTIVITY =',1PD10.4,2X,'SIEMENS/METRE')                JPB
      IF (IPOLRN.EQ.1.AND.IDEBUG.EQ.0) WRITE(6,6000)
      IF (IPOLRN.EQ.2.AND.IDEBUG.EQ.0) WRITE(6,7000)
 6000 FORMAT(/21X,21HVERTICAL POLARISATION)
 7000 FORMAT(/21X,23HHORIZONTAL POLARISATION)
C******* AK IS THE WAVENUMBER.
   10 AK=0.02094395D0*FREQ
      AK2=AK*AK
      AKI=DCMPLX(0.0D0,AK)
      IF(IDEBUG.EQ.2)WRITE(6,8000)AK
 8000 FORMAT(' AK    =',E15.7, ' GRWAVE-219')
C NES IS THE SQUARE OF THE EARTHS REFRACTIVE INDEX.PSI0 IS THE SURFACE
C IMPEDANCE RELATIVE TO FREE SPACE.FOR VERTICAL POLARISATION THE
C REFRACTIVE INDEX AND SURFACE IMPEDANCE NEED SLIGHT MODIFICATION.
   20 NES=DCMPLX(EPSLON,-1.8E4*SIGMA/FREQ)
      PSI0=CDSQRT(NES-1.0D0)
      IF(IPOLRN.NE.1)GOTO 30
      PSI0=PSI0/NES
      CALL MODIFY(DEL,SC,D1P0,PSI0,DEL,D1P0,PSI0)
   30 IF(IDEBUG.EQ.2)WRITE(6,9000)NES,PSI0
 9000 FORMAT(' NES   =(',E14.7,',',E14.7,')'/' PSI0  =(',E14.7,',',E14.7
     1,')' ' GRWAVE-229')
C READ THE NUMBER (MAXIMUM 20) OF RECEIVER AND TRANSMITTER (THESE ARE
C INTERCHANGEABLE) HEIGHTS JR AND JT.READ JHT.READ THE RECEIVER HEIGHTS
C HR(LR) (LR=1,JR).READ THE TRANSMITTER HEIGHTS HT(LT) (LT=1,JT).THE
C FIELD IS COMPUTED FOR THE FOLLOWING COMBINATIONS OF HEIGHTS HR(LR)
C AND HT(LT).FOR JHT=1 ((LT=1,JT),LR=1,JR).FOR JHT=2 MUST HAVE JR=JT AND
C ((LT=LR,LR),LR=1,JR).FOR JHT=3 MUST HAVE JR=JT AND
C ((LT=LR,JR),LR=1,JR).
      DO 40 LT=1,JT
      DO 40 LR=1,JR
   40     DM(LR,LT)=DMAX
      IF(IDEBUG.GE.1)WRITE(6,10000)(HRR(LR),LR=1,JR)
10000 FORMAT('0TERMINAL HEIGHTS IN METRES'/' HRR=',7E15.7/(4X,7E15.7)
     1 /' GRWAVE-242')    
      IF(IDEBUG.GE.1)WRITE(6,11000)(HTT(LT),LT=1,JT)
11000 FORMAT(' HTT=',7E15.7/(4X,7E15.7) /' GRWAVE-245,259')
C COMPUTE MODIFIED HEIGHTS USING EARTH FLATTENING TRANSFORMATION.
      DO 50 LR=1,JR
        HRU(LR)=HRR(LR)
        A=1.57E-7*HRR(LR)
   50   HR(LR)=HRR(LR)*(1.0D0+A*(-0.5D0+A/3.0D0))
      DO 60 LT=1,JT
        HTU(LT)=HTT(LT)
        A=1.57E-7*HTT(LT)
   60   HT(LT)=HTT(LT)*(1.0D0+A*(-0.5D0+A/3.0D0))
      IF(IDEBUG.GE.1)WRITE(6,12000)(HR(LR),LR=1,JR)
12000 FORMAT('0MODIFIED TERMINAL HEIGHTS'/' HR=',7E15.7/(4X,7E15.7)
     1 /' GRWAVE-256')
      IF(IDEBUG.GE.1)WRITE(6,11000)(HT(LT),LT=1,JT)
C**********************
      IF(IDEBUG.EQ.0)WRITE(6,13000)DMIN,DMAX,DSTEP
13000 FORMAT(/21X,'MINIMUM DISTANCE =',F10.3,2X,'KILOMETRES'
     1 /21X,'MAXIMUM DISTANCE =',F10.3,2X,'KILOMETRES'
     2 /21X,'DSTEP            =',F10.3 ,2X,'KILOMETRES')
C*****************************
      LTMIN=1
      LTMAX=JT
      IALT=1
      DO 80 LR=1,JR
        IF(JHT.NE.1)LTMIN=LR
        IF(JHT.EQ.2)LTMAX=LR
      DO 80 LT=LTMIN,LTMAX
C*************
C  Save DMIN in case it gets changed in GEOMOP                          jfc
      DMIN0=DMIN                                                        jfc
C COMPUTE THE FAR FIELD IF IG=-1 OR 0
   70 IF(IG.LE.0)CALL RESIDH(IALT,DEL,SC,D1P0,PSI0,DMIN,DMAX,
     1 DSTEP ,LOGLIN,JR,JT,LR,LT,HR,HT,DM,DA,EDBA,TL,NA)
       IALT=2
C COMPUTE THE NEAR FIELD IF IG=0 OR 1.
      IF(IG.GE.0)CALL GEOMOP(DEL,SC,D1P0,PSI0,DMIN,DMAX,
     1 DSTEP, LOGLIN,JR,JT,LR,LT,HR,HT,DM)
C**********************
C PRINT THE COMPUTED FIELD STRENGTH FROM RESIDH
      IF(IG.LT.0)WRITE(6,13500)FREQ,HTU(LT),HRU(LR)
13500 FORMAT(//21X,'FREQUENCY =',F9.3,' MHZ'//21X,'TRANSMITTER HEIGHT ='
     1,F8.1,2X,'METRES'/21X,'RECEIVER HEIGHT    =',F8.1,2X,'METRES'//21X
     2,'DISTANCE      FIELD STRENGTH     BASIC TRANSMISSION LOSS'/21X,'
     3  KM            DB(UV/M)               DB')
      IF(IG.LE.0.AND.IDEBUG.EQ.0)WRITE(6,14000)
14000 FORMAT(1H ,73X,'(R)')
      IF(IG.LE.0.AND.IDEBUG.EQ.0)WRITE(6,15000)(DA(N1),EDBA(N1),TL(N1),
     1 N1=NA,100)
15000 FORMAT(1H ,22X,F7.2,7X,F7.2,14X,F7.2)
C     Restore DMIN                                                      jfc
      DMIN=DMIN0
   80 CONTINUE

      END SUBROUTINE GRWAVE


      SUBROUTINE PROF(NS,HSCALE,DEL,SC,D1P0)
C PROF READS THE SURFACE REFRACTIVITY NS IN N-UNITS AND HEIGHT
C SCALE HSCALE IN KILOMETRES FOR THE EXPONENTIAL REFRACTIVITY
C VARIATION N=NS*EXP(-H/HSCALE) AND COMPUTES RELATED PARAMETERS.
C
C*******THESE PARAMETERS ARE FOR HORIZONTAL POLARISATION.**************
C IT READS NS AND HSCALE FROM GRWAVEDP.
C IT IS CALLED BY THE MAIN PROGRAM (=GRWAVE).
C CCIR REFERENCE EXPONENTIAL ATMOSPHERE
C
C PROFB IS CALLED BY GRWAVE
C
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 NS,K0
      COMPLEX*16 AKI
      COMMON/BUGGER/M,IDEBUG,AK,AK2,AKI
C
C********  DEL=2*DELTA. =IN EQUATION (2),SR(II).
C
      DEL=2.E-6*NS
C
C*******SC=(EARTH RADIUS)/(2.*HSCALE)
C
      SC=3.185E3/HSCALE
C
C******** K0=EFFECTIVE EARTH'S RADIUS FACTOR =1.3755 .IN EQU. (8),SR(II)
C
      K0=1.0D0/(1.0D0+DEL*(1.0D0-SC))
C
C********DIP0=2/(EFFECTIVE EARTH'S RADIUS)
C
      D1P0=3.14E-7/K0
C
      IF(IDEBUG.GE.1)WRITE(6,2000)NS,HSCALE,DEL,SC,K0
 2000 FORMAT('0NS=',E15.7,'   HSCALE=',E15.7,'   DEL=',E15.7,
     1'   SC=',E15.7,'   K0=',E15.7 /' PROF-329')
      IF(IDEBUG.EQ.0)WRITE(6,3000)NS,HSCALE
C 3000 FORMAT(//21X,10HATMOSPHERE/20X,2HNS,8X,2HH0/18X,F6.2,4X,F6.3)
3000   FORMAT(//21X,'ATMOSPHERIC CONSTANTS'/25X,'REFRACTIVITY =',F6.2 ,
     1 2X,'(N-UNITS)'/25X,'SCALE HEIGHT =',F6.3,2X,'KM')

      END Subroutine PROF


      SUBROUTINE MODIFY(DEL,SC,D1P0,PSI0,DELV,D1P0V,PSI0V)
C MODIFY MODIFIES THE VALUES OF PSI0,DEL AND K0 FOR VERTICAL
C POLARISATION.
C************************************************************
C THIS IS CALLED BY THE MAIN PROGRAM.
C CCIR IS THE REFERENCE EXPONENTIAL ATMOSPHERE.
C
C MODIFY IS CALLED BY GRWAVE
C
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16 PSI0,AKI,PSI0V                                        JPB
      REAL*8 K0
      COMMON/BUGGER/M,IDEBUG,AK,AK2,AKI
C
C*****PSI0= THE NORMALISED SURFACE IMPEDENCE (=FOR VERTICAL POLARISATION
C         =EQUATION  (10) SR(III)
      PSI0V=PSI0+DEL*SC/(6.37E6*(1.0D0+DEL)*AKI)
C
C*****DEL=2*DELTA(=FOR VERTICAL POLARISATION.=EQUATION (5) SR(I) )
C
      DELV=DEL*(1.+SC*SC/(2.028345E13*AK2))
C
C*****K0=EFFECTIVE EARTH'S RADIUS FACTOR FOR VERTICAL POLARISATION
C       =EQUATION (8) SR(II)
      K0=1.0D0/(1.0D0+DELV*(1.0D0-SC))
C
C*****DIP0=2/(EFFECTIVE EARTH'S RADIUS FACTOR).FOR VERTICAL POLARISATION
C         =EQUATION  (8) SR(II)
      D1P0V=3.14E-7/K0
C
      IF(IDEBUG.GE.1)WRITE(6,1000)DELV,K0
C
 1000 FORMAT(' MODIFIED VALUES FOR VERTICAL POLARISATION   DEL=',
     1E15.7,'   K0=',E15.7, ' MODIFY-368')

      END SUBROUTINE MODIFY


      FUNCTION ABS2(X)
C ABS2 COMPUTES THE MODULUS SQUARED OF A COMPLEX VARIABLE X.
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16 X
C     CALL UNFLOW ***Marconi mainframe routine***
      XR=DREAL(X)                                                       JPB
      XI=DIMAG(X)
      ABS2=XR*XR+XI*XI

      END FUNCTION ABS2
C----------------------------------------------------------------------
C
      FUNCTION BTLC(H1,H2,F,IP)
C
C     BASIC TRANSMISSION LOSS CONSTANT, CALCULATED ASSUMING PERFECTLY
C     CONDUCTING GROUND NEAR THE AERIALS.
C     BASIC TRANSMISSION LOSS BTL = BTLC - E, WHERE E IS THE RECEIVED
C     FIELD STRENGTH IN DECIBELS ABOVE 1 MICROVOLT PER METRE WHEN THE
C     TRANSMITTER PRODUCES A FIELD OF 150.0 MICROVOLTS PER METRE AT
C     1 KILOMETRE IN FREE SPACE (AS IN STEPHEN ROTHERAM'S GRWAVE).
C
C     ARGUMENTS:  H1,H2  AERIAL HEIGHTS IN METRES
C                 F      FREQUENCY IN HERTZ
C                 IP     POLARISATION: 1 VERTICAL, 2 HORIZONTAL
C
      IMPLICIT REAL *8(A-H,O-Z)
      AK=2.094395D-8*F                                                  JPB
      RR=1.0D0
      X=2.0D0*AK*H1                                                     JPB
      IF (IP.EQ.2) GO TO 30
      DO 20 I=1,2
        IF (X.LT.0.1D0) GO TO 10                                        JPB
        RR=RR*(1.0D0+3.0D0*(DSIN(X)-X*DCOS(X))/X/X/X)                   JPB
        GO TO 20
   10   XSQ=X*X
        RR=RR*(2.0D0-XSQ*(0.1D0+XSQ*3.571429D-3))                       JPB
   20   X=2.0D0*AK*H2
      GO TO 60
   30 DO 50 I=1,2
        IF (X.LT.0.1D0) GO TO 40                                        JPB
        RR=RR*(1.0D0+1.5D0*((1.0D0-X*X)*DSIN(X)-X*DCOS(X))/X/X/X)       JPB
        GO TO 50
   40   XSQ=X*X
        RR=RR*(XSQ*(0.2D0-XSQ*(1.071429D-3+XSQ*2.645503D-4)))           JPB
   50   X=2.0D0*AK*H2                                                   JPB
   60 Y=AK*AK*RR
      IF (Y.LT.1D-70) GO TO 70                                          JPB
      BTLC=169.542D0+10.0D0*DLOG10(Y)                                   JPB
      RETURN
   70 BTLC=1000.0D0

      END FUNCTION BTLC


      SUBROUTINE PFUNCS(N,H)
C PFUNCS COMPUTES THE FUNCTION P AND ITS FIRST N DERIVATIVES DP(M)
C (M=1,N) AT COMPLEX HEIGHT H.IF N=0 ONLY P IS COMPUTED.N HAS A
C MAXIMUM OF 4.IF M2(H) IS THE SQUARE OF THE MODIFIED REFRACTIVE
C INDEX THEN P(H) IS
C       P(H) = M2(H) - M2(0) + P0(M)
C       P0(M)=S**2-M2(O)
C       P(H) =M2(H) -S**2
C
C SEE EQUATIONS 10 AND 11  SRI
C
C PFUNCS IS CALLED BY EIGEN,NEWHTG,TPOINT,HFI,HR,RAY,GEOMOP,PINT,PINTAB,
C AND YCALC.IT DOES NOT CALL UPON ANY FUNCTION OR cSUBROUTINE.
C
      IMPLICIT REAL *8(A-H,O-Z)
      COMPLEX*16 H,X,Y(2),Z(2),Z2,DELU,P,P0(9),T,DP(4),FID(9),AKI
      COMMON /BUGGER/M,IDEBUG,AK,AK2,AKI /PEES/P,DP /PEXCIT/P0,FID
     1 /EARTH/DEL,SC,D1P0
      Z(2)=(0.0D0,0.0D0)
      DO 20 J=1,2
        IF(J.EQ.1)X=1.57D-7*H
C X=H/EARTH'S RADIUS(=R0)
        IF(J.EQ.2)X=-2.0D0*SC*Y(1)
C X=-R0/HSCALE*(EXP(H/R0)-1)
        X2=ABS2(X)
        IF(X2.GT.0.25D0)GOTO10
        Y(J)=1.0D0
        IF(X2.GT..0001D0)Y(J)=1.0D0+X/5.0D0*(1.0D0+X/6.0D0*(1.0D0+X/
     1    7.0D0*(1.0D0+X/8.0D0)))
        Y(J)=X*(1.0D0+X/2.0D0*(1.0D0+X/3.0D0*(1.0D0+X*Y(J)/4.0D0)))
C Y(1)=EXP(H/R0)
        Z(J)=1.0D0+Y(J)
C Z(1)=1+EXP(H/R0)
        GOTO20
   10   IF(DREAL(X).GT.-50.0D0)Z(J)=CDEXP(X)                            JPB
        Y(J)=Z(J)-1.0D0
   20   CONTINUE
      DELU=DEL*Z(2)
      P=Y(1)*(2.0D0+Y(1))*(1.0D0+DELU)+DEL*Y(2)+P0(M)
C P=EQUATION 17(SRIII)+P0(M)
      IF(N.EQ.0)RETURN
      T=SC*Z(1)
      Z2=Z(1)*Z(1)
      DP(1)=3.14D-7*Z2*(1.0D0+DELU*(1.0D0-T))
C DP(1)=FIRST DERIVATIVE OF P(H) WRT H.
      IF(N.EQ.1)RETURN
      DP(2)=9.8596D-14*Z2*(1.0D0+DELU*(1.0D0-T*(2.5D0-T)))
C SECOND DERIVATIVE OF P(H) WRT H
      IF(N.EQ.2)RETURN
      DP(3)=3.095914D-20*Z2*(1.0D0+DELU*(1.0D0-T*(4.75D0-T*(4.5D0-T))))
C THIRD DERIVATIVE OF P(H)
      IF(N.EQ.3)RETURN
      DP(4)=9.721171D-27*Z2*(1.0D0+DELU*(1.0D0-T*(8.125D0-T*(13.75D0-T*
     1  (7.0D0-T)))))
C FOURTH DERIVATIVE OF P(H)

      END SUBROUTINE PFUNCS


      SUBROUTINE TPOINT(DEL,SC,M,P0,H1)
C TPOINT COMPUTES THE TURNING POINT H1(M) OF THE DIFFERENTIAL
C EQUATION.THIS IS THE SOLUTION OF P(H)=0.
C
      IMPLICIT REAL *8(A-H,O-Z)
      COMPLEX *16 H1(9),P0(9),TERM,P,DP(4),AKI,D1P,D2P
      COMMON/BUGGER/N,IDEBUG,AK,AK2,AKI /PEES/P,DP
      EQUIVALENCE(D1P,DP(1)),(D2P,DP(2))
      IF(DREAL(P0(M)).LT.1.D-3)GOTO 40                                  JPB
      C=DEL*SC
      IF(DREAL(P0(M)).LT.1.D-2)GOTO 30                                  JPB
      YR=(DEL-0.5*DREAL(P0(M)))/(1.+C)                                  JPB
      YRT=YR
      DO 10 ITER=1,9
        A=2.0*YR-DEL+DREAL(P0(M))                                       JPB
        C=2.0*SC*YR
        D=0.0D0
        IF(C.GT.-20.0D0)D=DEXP(C)                                       JPB
        B=(3.141593+SC*DIMAG(P0(M)))/(SC+D/DEL)
        YR=-0.25/SC*DLOG((A*A+B*B)/(DEL*DEL))
        IF(DABS(1.0D0-YRT/YR).LT.1.D-3)GOTO 20                          JPB
   10 YRT=YR
      IF(IDEBUG.GE.1)WRITE(6,1000)
 1000 FORMAT(' YR HAS NOT CONVERGED' ' TPOINT-505')
      STOP
   20 YI=0.5*(B-DIMAG(P0(M)))
      H1(M)=6.37D6*DCMPLX(YR,-YI)
      GOTO 50
   30 B=DLOG(C)
      A=3.185D6/SC                                                      JPB
      H1(M)=A*(B+(1.0D0,-1.0D0)*CDSQRT((0.0D0,1.0D0)*(-1.-B+C-SC*P0(M)))
     1 )
CC    IF(IDEBUG.EQ.2)PRINT*,'H1(M)',H1(M) ,'TPOINT-515'
      GOTO 50
   40 H1(M)=-3.185D6*P0(M)                                              JPB
cc    IF(IDEBUG.EQ.2)PRINT*,'H1(',M,')',H1(M) ,'TPOINT-518'
   50 DO 60 ITER=1,9
        CALL PFUNCS(1,H1(M))
C     IF(IDEBUG.EQ.2)PRINT*,'P',P,'D1P',D1P ,'TPOINT-521'
        TERM=P/D1P
        H1(M)=H1(M)-TERM
C     IF(IDEBUG.EQ.2)PRINT*,'TERM',TERM,'H1(M)',H1(M) ,'TPOINT-524'
        EPS=ABS2(TERM/H1(M))
        IF(EPS.LT.1.D-11)RETURN
   60   CONTINUE
      IF(IDEBUG.GE.1)WRITE(6,2000)TERM,M,H1(M) 
 2000 FORMAT(' TERM=(',E14.7,',',E14.7,')   H1(',I1,')=(',E14.7
     1,',',E14.7,')' ' TPOINT-528')

      IF(EPS.LT.1.D-6)RETURN

      STOP

      END SUBROUTINE TPOINT


      FUNCTION ZXI(N,X,Z)
C A FUNCTION USED IN PSTART.
      IMPLICIT REAL *8(A-H,O-Z)
      COMPLEX *16 ZXI,X,Z
C     PRINT*,'N',N,'X',X,'Z',Z
      ZXI=1.0D0/(Z-X*X)

      END FUNCTION ZXI


      FUNCTION ZPSI(N,Y,Z)
C A FUNCTION USED IN PSTART.
      COMPLEX*16 ZPSI,Y,Z
      ZPSI=1.0D0/(1.0D0-Z*Y*Y)

      END FUNCTION ZPSI


      SUBROUTINE RUNKT1(F,Y1,Y2,X1,H,N)
C THIS PERFORMS A SINGLE STEP OF THE 4 TH ORDER RUNGE-KUTTA METHOD
C ON THE N FIRST ORDER DIFFERENTIAL EQUATIONS DY/DX=F(J,X,Y)
C WHERE J=1,N AND Y IS AN N ELEMENT ARRAY.THE INITIAL VALUES ARE
C Y=Y1 AT X=X1 AND THE FINAL VALUES ARE Y=Y2 AT X=X1+H.
C
C Y2=Y1+(1/6K1)+(1/3*K2)+(1/3*K3)+(1/6*K4)
C K1=H*F(J,X1,Y1)
C K2=H*F(X1+H/2,Y1+K1/2)
C  ECT.
C SEE PAGE 259 CURTIS F. GERALD :'NUMERICAL ANALYSIS'
C
C RUNKT1 IS CALLED BY RUNKT2 .
C
      IMPLICIT REAL *8(A-H,O-Z)
      COMPLEX *16  F,Y1(N),Y2(N),X1,H,AK(4),X,Y(4)
      REAL *8 A(4),B(4)
      EXTERNAL F
      DATA A/0.0D0,0.5D0,0.5D0,1.0D0/
      DATA B/0.1666667,0.3333333,0.3333333,0.1666667/
      DATA AK/(0.0D0,0.0D0),(0.0D0,0.0D0),(0.0D0,0.0D0),(0.0D0,0.0D0)/
        DO 10 J=1,N
   10     Y2(J)=Y1(J)
        DO 30 I=1,4
          X=X1+A(I)*H
        DO 20 J=1,N
   20     Y(J)=Y1(J)+A(I)*AK(J)
        DO 30 J=1,N
          AK(J)=H*F(J,X,Y)
   30     Y2(J)=Y2(J)+B(I)*AK(J)

      END SUBROUTINE RUNKT1


      SUBROUTINE RUNKT2(F,YI,YF,XI,XF,ERROR2,STEPIN,N,MSTEP)
C THIS INTEGRATES THE N FIRST ORDER DIFFERENTIAL EQUATIONS
C DY/DX=F(J,X,Y) WHERE J=1,N AND Y IS AN N ELEMENT ARRAY.THE
C 4 TH ORDER RUNGE-KUTTA METHOD IS USED.THE INITIAL VALUES
C ARE Y=YI AT X=XI AND THE FINAL VALUES ARE Y=YF AT X=XF.THE
C RELATIVE TRUNCATION ERROR SQUARED IS KEPT CLOSE TO ERROR2.
C STEPIN IS THE INITIAL FRACTION OF XF-XI TO BE USED AS STEP SIZE.
C STEPIN SHOULD NOT BE GREATER THAN .5.
C        ---------------------
C        ! 2*10-4<STEPIN<0.5 !
C        ---------------------
C     MSTEPS HAS BEEN INCREASED FROM 500 TO 700. RSGILL 18/9/85.
C RUNKT2 IS CALLED BY EIGEN ,PSTART AND NEWHTG.IT CALLS  RUNKT1.
C
      IMPLICIT REAL *8(A-H,O-Z)
      COMPLEX*16 F,YI(N),YF(N),XI,XF,DX,H,X1,Y1(4),Y3S(4),Y2(4),TERROR,
     1 EC,AKI
      COMMON /STEP/H,L /BUGGER/M,IDEBUG,AK,AK2,AKI
C STEP/H,L ARE REQUIRED IN HFI AND HR..
      EXTERNAL F
C THIS F SATIFIES: DY/DX=F(J,X,Y)
C
C INITIALISE VARIABLES.
      L=-1
      MSTEP=0
      IFIN=0
      STEP=DMIN1(0.5D0,STEPIN)
C     IF(IDEBUG.EQ.2)PRINT*,'STEPIN',STEPIN,'STEP',STEP ,'RUNKT2-606'
C SELECT SMALLEST VALUE FROM LIST
      IF(STEP.GE.0.5D0)IFIN=1
      DX=XF-XI
      H=STEP*DX
      TAU=0.0D0
      X1=XI
C     IF(IDEBUG.EQ.2)PRINT*,'DX',DX,'H',H,'X1',X1 ,'RUNKT2-613'
      DO 10 J=1,N
   10   Y1(J)=YI(J)
C THIS PUTS THE INITIAL VALUES YI(N) INTO Y1(N)
C
C PERFORM A DOUBLE LENGTH STEP FROM X1 TO X1+2*H AND TWO SINGLE
C LENGTH STEPS FROM X1 TO X1+H AND X1+H TO X1+2*H.
C
   20 CALL RUNKT1(F,Y1,Y3S,X1,2.0D0*H,N)
C
C Y3S=Y1+1/6(2.*H*F(X1,Y1)+2(2H*F(X1+1/2(2H),Y1+1/2(2H)......)
C
   30 CALL RUNKT1(F,Y1,Y2,X1,H,N)
C
C Y2=Y1+1/6(H*F(X1,Y1)+2(H*F(X1+1/2*H,Y1+1/2*H).............)
C
      CALL RUNKT1(F,Y2,YF,X1+H,H,N)
C X1=X1+H
C YF=Y1+1/6(H*F(X1,Y1)+2(H*F(X1+1/2*H,Y1+1/2*H).............)
C
C ESTIMATE THE TRUNCATION ERROR TERROR AND USE THIS TO IMPROVE
C YF.COMPUTE THE AVERAGE OF THE MODULUS SQUARED OF THE RELATIVE
C TRUNCATION ERROR ERR2.COMPARE ERR2 WITH ERROR2.
      MSTEP=MSTEP+1
      IF(MSTEP.GE.1000)GOTO80
      ERR2=0.0D0
      DO 40 J=1,N
        TERROR=(YF(J)-Y3S(J))/15.0D0
C
C IN 4TH ORDER RUNGE KUTTA METHOD THE TRUNCATION ERROR=DELTA/15
C WHERE DELTA=(YF-Y3S)/(2**4-1)==(YF-Y3S)/15 WHERE YF IS THE VALUE
C OBTAINED BY 2 STEPS INTEGRATIONS.THAT IS INTEGRATING F(J,X,Y) FROM X1
C TO X1+H AND X1+H TO X1+2H.Y3S IS THE VALUE OBTAINED BY A SINGLE STEP
C INTEGRATION WITH DOUBLE SPACING.
C SEE P/292 OF HILDEBRAND'S 'NUMERICAL ANALYSIS'
C
        YF(J)=YF(J)+TERROR
C
C EQUATION 6.14.15 OF HILDEBRAND
        EC=Y1(J)+Y2(J)+YF(J)
C
C EC=Y1+INTEGRAL OF F(X,Y) FROM X1 TO X1+H +THE INTEGRAL OF F(X,Y) FROM
C X1+H TO (X1+H)+H.
C
        E=DABS(DREAL(EC))+DABS(DIMAG(EC))                               JPB
        IF(E.LT.1.D-10)GOTO40
        ERR2=ERR2+ABS2(TERROR/(Y1(J)+Y2(J)+YF(J)))
   40   CONTINUE
        ERR2=9.0D0*ERR2/N
        IF(ERR2.GT.5.0D0*ERROR2.AND.STEP.GT.0.0002D0)GOTO60
C TRUNCATION ERROR SATISFACTORY.IF IFIN=1,THE INTEGRATION ENDS.
        IF(IFIN.EQ.1)RETURN
C PREPARE VALUES AND STEP SIZE FOR NEXT STEP.
        L=0
      DO 50 J=1,N
   50   Y1(J)=YF(J)
        X1=X1+2.0D0*H
        TAU=TAU+2.0D0*STEP
        IF(ERR2.EQ.0.0D0)ERR2=1.D-14
        STEP=DMAX1(0.0002D0,STEP*(ERROR2/ERR2)**0.10D0)
        IF(STEP.EQ..0002D0.AND.IDEBUG.GE.1)WRITE(6,1000)ERR2,X1,YF
 1000   FORMAT(' WARNING.MINIMUM ALLOWED STEP SIZE.ERR2=',E15.7,
     1' X1=(',E14.7,',',E14.7,')'/' YF',(1X,8E15.7) ' RUNKT2-673,685')
        IF((TAU+2.D0*STEP).GE.1.D0)IFIN=1                               JPB
        IF(IFIN.EQ.1)STEP=(1.0D0-TAU)/2.0D0
        H=STEP*DX
      GOTO 20
C TRUNCATION ERROR TOO BIG.HALVE THE STEP SIZE.
   60   IFIN=0
        L=1
        STEP=DMAX1(0.0002D0,0.5D0*STEP)
        H=STEP*DX
        IF(STEP.EQ..0002D0.AND.IDEBUG.GE.1)WRITE(6,1000)ERR2,X1,YF
        DO 70 J=1,N
   70   Y3S(J)=Y2(J)
      GOTO 30
C MORE THAN 500 STEPS USED.INTEGRATION STOPS.
   80   IF(IDEBUG.GE.1)WRITE(6,2000)
 2000   FORMAT(' 1000 STEPS USED IN RUNKT2' ' RUNK2-690')
      STOP

      END SUBROUTINE RUNKT2


      BLOCK DATA
C WEIGHTS AND ABSCISSAS FOR 16 POINT GAUSSIAN QUADRATURE WITH
C WEIGHT FUNCTIONS SQRT(X),1/SQRT(X) AND 1.
C
C COMMON QUAD16 IS REQUIRED IN PINT,GQ16 IN PINTAB AND YCALC AND AIRYS
C IN PSTART.
      IMPLICIT REAL*8(A-H,O-Z)
      COMMON /AIRYS/AS,ASD /QUAD16/W1,Y1,W2,Y2 /GQ16/W3,Y3
      REAL*8 W1(16),Y1(16),W2(16),Y2(16),W3(16),Y3(16),AS(10),ASD(10)
      DATA W1/.01314449,.02981894,.04470995,.05692274,.06578789,
     1 .07089086,.07210076,.06957807,.06375982,.05532300,.04512950,
     1 .03415651,.02341822,.01388466,.006404388,.001636870/
      DATA Y1/
     2 .005143979,.02690510,.06525346,.1188529,.1858245,.2638194,
     3 .3501023,.4416466,.5352415,.6276043,.7154952,.7958316,.8657955,
     3 .9229332,.9652404,.9912332/
      DATA W2/
     4 .01403722,.03254879,.05078413,.06854773,.08567180,.1019961,
     5 .1173682,.1316444,.1446916,.1563878,.1666238,.1753042,.1823478,
     5 .1876888,.1912774,.1930802/
      DATA Y2/
     6 .005464790,.02856995,.06923379,.1259506,.1966084,.2785747,
     7 .3687955,.4639093,.5603723,.6545902,.7430525,.8224631,.8898632,
     7 .9427416,.9791279,.9976664/
      DATA W3/
     8 .18945061,.18945061,.18260342,.18260342,.16915652,.16915652
     9 ,.14959599,.14959599,.12462897,.12462897,.09515851,.09515851,
     9 .06225352,.06225352,.02715246,.02715246/
      DATA Y3/
     1 -.09501251,.09501251,-.28160355,.28160355,-.45801678,
     2 .45801678,-.61787624,.61787624,-.7554044,.7554044,-.86563120,
     2 .86563120,-.94457502,.94457502,-.98940093,.98940093/
C AS(10) ARE THE FIRST 10 ROOTS OF AI(Z)=0.ASD(10) ARE THE FIRST
C 10 ROOTS OF DAI(Z)/DZ=0.
      DATA AS/-2.338107,-4.087949,-5.520560,-6.786708,-7.944134,
     1-9.022651,-10.04017,-11.00852,-11.93602,-12.82878/
      DATA ASD/-1.018793,-3.248198,-4.820099,-6.163307,-7.372177,
     3-8.488487,-9.535449,-10.52766,-11.47506,-12.38479/
      END block data


      FUNCTION PINT(J,H,M,H1)
C PINT COMPUTES THE PHASE INTEGRAL (J=1),ITS FIRST (J=2) OR SECOND
C (J=3) DERIVATIVE WITH RESPECT TO P0(M) FROM H1(M) TO H.
C
C PINT(1,H)=K* THE INTEGRAL GIVEN BY EQUATION 13 SRI.H1(M) ARE THE
C TURNING POINTS.IT CALCULATED BY 16 POINT QUADRATURE.
C
C PINT IS CALLED BY PSTART , COMINT AND GEOMOP .IT CALLS PFUNCS.
C
      IMPLICIT REAL *8(A-H,O-Z)
      COMPLEX *16 PINT,H,H1(9),P,DP(4),D1P,D2P,AKI,F,Y                   JPB
      COMMON/BUGGER/N,IDEBUG,AK,AK2,AKI /PEES/P,DP/QUAD16/W1(16),
     1Y1(16),W2(16),Y2(16)
      EQUIVALENCE(D1P,DP(1)),(D2P,DP(2))
C
C Y1,W1,Y2 AND W2 ARE THE GAUSSIAN ABCISSAS AND THE WEIGHTS
C
      F=H-H1(M)
      PINT=(0.0D0,0.0D0)
      IF(IDEBUG.EQ.2.AND.CDABS(P).EQ.0.0D0)PRINT*,'P=',P, 'PINT-752'
      F1=ABS2(F)
      F2=ABS2(H1(M))*1.0D-6
      IF(F1.LE.F2)RETURN                                                JPB
C
      DO 40 I=1,16
C
        GOTO(10,20,30),J
C
   10   Y=H-F*Y1(I)                                                     JPB
        CALL PFUNCS(0,Y)                                                JPB
        IF(IDEBUG.EQ.2.AND.Y.EQ.(0.0D0,0.0D0))PRINT*,'Y=',Y, 'PINT-763' JPB
        PINT=PINT+W1(I)*(1.0D0,1.0D0)*CDSQRT((0.0D0,-.5D0)*P/(1.0D0-Y1
     1   (I)))
C
        GOTO40
   20   CALL PFUNCS(0,H-F*Y2(I))
        PINT=PINT+W2(I)*(1.0D0,-1.0D0)*CDSQRT((1.0D0-Y2(I))/((0.D0,
     1  -2.0D0)* P))
        GOTO40
   30   CALL PFUNCS(2,H-F*Y2(I))
        PINT=PINT+W2(I)*D2P/(D1P*D1P)*(1.0D0,-1.0D0)*CDSQRT((1.0D0-
     1  Y2(I))/((0.0D0,- 2.0D0)*P))
C
   40   CONTINUE
C
      GOTO(50,60,70),J
   50 PINT=AKI*F*PINT
      RETURN
   60 PINT=0.5D0*AKI*F*PINT
      RETURN
   70 CALL PFUNCS(1,H)
      PINT=0.5D0*AKI*((1.0D0,-1.0D0)/(D1P*CDSQRT((0.0D0,-2.0D0)*P))+
     1 F*PINT)

      END FUNCTION PINT


      SUBROUTINE PSTART(M,PSI0,DEL,SC,D1P0,H1)
C PSTART COMPUTES AN INITIAL VALUE FOR THE PROPAGATION CONSTANT
C P0(M) DERIVED FROM A UNIFORM APPROXIMATION BASED ON AIRY INTEGRAL
C FUNCTIONS (LANGERS METHOD OR THE EXTENDED WKB APPROXIMATION).
C
C SEE SECTION 3.2 IN SRI AND SRII
C
C
C PSTART IS CALLED BY EIGEN AND IT IN TURN CALLS TPOINT,RUNKT2.IT ALSO
C USES THE EXTERNAL FUNCTIONS PINT, ZXI AND ZPSI
C
      IMPLICIT REAL *8(A-H,O-Z)
      LOGICAL LARGE
      COMPLEX*16 FAC,DP(4),XI,PSI0,Z0T(1),ZXI,Z0(1),ZPSI,PHINT,
     1P0(9),H1(9),TERM,P,F,DF,AKI,XIT,PINT,PSIT,P0T,D1P,D2P,FID(9)
      COMMON /BUGGER/N,IDEBUG,AK,AK2,AKI /PEES/P,DP /PEXCIT/P0,FID  
     1/AIRYS/AS(10),ASD(10) /HCHITE/HCH(9)
      EXTERNAL ZXI,ZPSI
C
C COMPUTE AN INITIAL VALUE FOR XI.
C
      IF(D1P0.GT.0.0D0)FAC1=(AK2*D1P0)**(1.D0/3.D0)
C
C FAC1=(K**2*2/RE)**1/3
C
C RE =EFFECTIVE EARTH'S RADIUS
C
      IF(D1P0.LE.0.0D0)FAC1=(AK2*3.14D-7)**(1.D0/3.D0)
C
C FAC1=(K**2/R0)**1/3
C
      FAC=AK/FAC1*(0.8660254D0,0.5D0)
C
C FAC=(K/(2/RE))**1/3*EXP(I*PI/6)
C
      XI=FAC*PSI0
C
C XI=FAC*SURFACE IMPEDENCE
C
C DETERMINE WHETHER XI IS SMALL OR LARGE.
C
      ATAU=4.724D0*(M-0.5D0)
C
      ATAU=ATAU*ATAU
      A=ABS2(XI)
      LARGE=.FALSE.
      IF(A*A*A.GT.ATAU)LARGE=.TRUE.
C INITIALISE Z0T,XIT,PSIT.
      IF(.NOT.LARGE)Z0T(1)=ASD(M)
      IF(LARGE)Z0T(1)=AS(M)
C     IF(IDEBUG.EQ.2)PRINT*,'Z0T(1)',Z0T(1) ,'PSTART-838'
C
C AS(10) ARE THE FIRST 10 ROOTS OF AI(Z)=0
C ASD(10) ARE THE FIRST 10 ROOTS OF DAI(Z)/DZ=0.THESE ARE STORED IN
C DATA FORTRAN.
      XIT=0.D0
      PSIT=0.D0
      IF(IDEBUG.EQ.2)WRITE(6,1000)M
 1000 FORMAT('0ITERAT',3X,'MSTEP',18X,'P0(',I1,')',33X,'Z0',35X,'XI'
     1 ' PSTART-846')
C
C ITERATION CYCLE FOR Z0.
        DO 70 ITERAT=1,9
C
C XI SMALL.FIND Z0,THE SOLUTION OF
C RELATION BETWEEN T AND XI IS T=XI*K**2/3.THEREFORE SOLVE FOR Z0 WHEN
C T IS SMALL.
C         DAI(Z0)/DZ0=XI*AI(Z0)
C WHERE AI(Z0) IS THE AIRY INTEGRAL FUNCTION.LET
C         X=(DAI(Z)/DZ)/AI(Z)
C
C EQUATION 18 SRII
C
C THEN Z(X) SATISFIES
C         DZ/DX=ZXI(X,Z)=1./(Z-X*X)
C THIS IS INTEGRATED FROM Z=Z0T AT X=XIT TO Z=Z0 AT X=XI.FOR THE
C FIRST INTEGRATION Z0T=ASD(M) AT XIT=0 WHERE ASD(M) IS THE M TH
C ROOT OF DAI(Z)/DZ.
C
C  THIS = AN';EQUATION 24 SRII
C
        IF(LARGE)GOTO 10
        CALL RUNKT2(ZXI,Z0T,Z0,XIT,XI,1.D-10,0.5D0,1,MSTEP)
C     IF(IDEBUG.EQ.2)PRINT*,'Z0T',Z0T,'Z0',Z0,'XIT',XIT ,'PSTART-871'
        GOTO 20
C
C  SOLVE FOR Z0 WHEN T IS LARGE
C
C XI LARGE.LET PSI=1/XI,PSIT=1/XIT,Y=1/X.Z(Y) SATISFIES
C         DZ/DY=ZPSI(Y,Z)=1./(1-Z*Y*Y)
C
C THIS =AN;EQUATION 25 SRII
C
C THIS IS INTEGRATED FROM Z=Z0T AT Y=PSIT TO Z=Z0 AT Y=PSI.FOR THE
C FIRST INTEGRATION Z0T=AS(M) AT PSIT=0 WHERE AS(M) IS THE M TH
C ROOT OF AI(Z).
C
   10   CALL RUNKT2(ZPSI,Z0T,Z0,PSIT,1./XI,1.D-10,0.5D0,1,MSTEP)
C     IF(IDEBUG.EQ.2)PRINT*,'Z0T',Z0T,'Z0',Z0,'PSIT',PSIT ,'PSTART-886'
C
C Z0 IS RELATED TO THE PHASE INTEGRAL WHICH DEPENDS UPON P0(M),
C THE PROPAGATION CONSTANT.P0(M) IS FOUND BY NEWTONS METHOD.
C
   20   PHINT=(0.0D0,.6666667D0)*Z0(1)*CDSQRT(-Z0(1))
C     IF(IDEBUG.EQ.2)PRINT*,'PHINT',PHINT ,'PSTART-892'
C
C INITIALISE P0(M).ITERATION CYCLE FOR P0(M).COMPUTE THE TURNING
C POINT H1(M).
        IF(ITERAT.GT.1)GOTO 30
        P0(M)=Z0(1)/(FAC*FAC)
C
      IF(IDEBUG.EQ.2)PRINT*,'P0(M)',P0(M), 'PSTART-899'
C P0(M)=Z0/(I/P0(1))**2/3,P0(1)=2/RE.THIS IS AFTER EQUATION 25 SRII.
C
        P0T=P0(M)
   30   DO 50 ITER=1,9
          CALL TPOINT (DEL,SC,M,P0,H1)
C
C COMPUTE P0(M) BY NEWTONS METHOD.COMPUTE THE PHASE INTEGRAL
C AND ITS DERIVATIVE BY 16-POINT GAUSSIAN INTEGRATION (SEE
C ABRAMOWITZ AND STEGUN 25.4.34 AND 25.4.36).
   40     TERM=(PHINT-PINT(1,(0.0D0,0.0D0),M,H1))/
     1 PINT(2,(0.0D0,0.0D0),M,H1)
          P0(M)=P0(M)+TERM
C     IF(IDEBUG.EQ.2)PRINT*,'TERM',TERM,'P0(',M,')',P0(M) ,'PSTART-912'
C
C THIS IS CALCULATED FROM EQUATION 17 SRII
C
          IF(ABS2(TERM/P0(M)).LT.1.D-8)GOTO 60
   50     CONTINUE
        IF(IDEBUG.GE.1)WRITE(6,2000)
 2000 FORMAT(' P0(M) HAS NOT CONVERGED' ' PSTART-918')
        error STOP
C TEST FOR CONVERGENCE.
   60   IF(IDEBUG.EQ.2)WRITE(6,3000)ITERAT,MSTEP,P0(M),Z0(1),XI
 3000 FORMAT(I5,I9,3(6X,'(',E14.7,',',E14.7,')') ' PSTART-922')
        IF(ABS2(1.0D0-P0T/P0(M)).LT.1.E-8)GOTO 80
C COMPUTE XI.
C
C THESE ARE NEW XIT,PSIT ,ZOT .INITIALLY XIT AND PSIT ARE ZERO
C
        XIT=XI
        PSIT=1.D0/XIT
        Z0T(1)=Z0(1)
        P0T=P0(M)
   70   XI=CDSQRT(Z0(1)/P0(M))*PSI0
C     IF(IDEBUG.EQ.2)PRINT*,'PSIT',PSIT,'P0(M)',P0(M),'XI',XI
C    1  ,'PSTART-934'
      IF(IDEBUG.GE.1)WRITE(6,4000)
 4000 FORMAT(' Z0 HAS NOT CONVERGED' ' PSTART-936')
      error STOP
C
C COMPUTE THE HEIGHT HCH(M) AT WHICH THE METHOD OF COMPUTING THE
C HEIGHT-GAIN FUNCTION CHANGES.
C
   80 Z02=ABS2(Z0(1))
      FAC3=73.D0-0.75D0*Z02
      IF(FAC3.LE.0.0D0)GOTO 90
      HCH(M)=(0.5D0*DSQRT(Z02)+DSQRT(FAC3))/FAC1                        JPB
      IF(HCH(M).GT.2.0D0*DREAL(H1(M)))RETURN                            JPB
   90 HCH(M)=2.0D0*DREAL(H1(M))                                         JPB
C     IF(IDEBUG.EQ.2)PRINT*,'HCH(M)',HCH(M) ,'PSTART-949'

      END SUBROUTINE PSTART


      FUNCTION HFI(J,H,FI)
C FI(1) IS THE WAVE IMPEDANCE AT THE HEIGHT H.FI(2) IS ITS DERIVATIVE
C WITH RESPECT TO THE PROPAGATION CONSTANT P0(M).THESE SATISFY
C THE FIRST ORDER DIFFERENTIAL EQUATIONS DFI(J)/DH=HFI(J,H,FI)
C WHERE J=1 OR 2 WHICH ARE INTEGRATED IN RUNKT2.
C
C
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16 H,FI(2),HSTEP,F(5),P,HFI,HFITAU,AKI,DP(4),D1P,D2P
      INTEGER JF,I(12)
      COMMON/BUGGER/M,IDEBUG,AK,AK2,AKI /PEES/P,DP/STEP/HSTEP,L
      DATA JF/1/
      DATA I/1,3,3,5,1,2,2,3,3,4,4,5/
      IHTG=1
      GOTO 10
      ENTRY HFITAU(J,H,FI)
C FI(1) IS THE WAVE IMPEDANCE AND FI(2) THE HEIGHT-GAIN FUNCTION
C AT THE HEIGHT H.THESE SATISFY THE FIRST ORDER DIFFERENTIAL
C EQUATIONS DFI(J)/DH=HFITAU(J,H,FI) WHERE J=1 OR 2 WHICH ARE
C INTEGRATED IN RUNKT2.
      IHTG=2
C ALL VALUES OF P FOR TWO STEPS OF THE RUNGE-KUTTA METHOD ARE
C COMPUTED IN THE FIRST CALL TO HFI OR HFITAU.
   10 IF(JF.GT.1.OR.J.EQ.2) GOTO(80,90),J
      IF(L)20,30,50
   20 CALL PFUNCS(0,H)
      F(1)=P
      GOTO 40
   30 F(1)=F(5)
   40 NM=1
      GOTO 60
   50 F(5)=F(3)
      F(3)=F(2)
      JF=5
      NM=2
   60 DO 70 N=1,4,NM
        CALL PFUNCS(0,H+0.5D0*N*HSTEP)
   70   F(N+1)=P
C COMPUTE HFI(1,H,FI).THIS IS THE SAME AS HFITAU(1,H,FI).
   80 NF=I(JF)
      HFI=-AK2*F(NF)-FI(1)*FI(1)
      JF=JF+1
      IF(JF.GE.13)JF=1
      RETURN
C COMPUTE HFI(2,H,FI) IF IHTG=1 OR HFITAU(2,H,FI) IF IHTG=2.
   90 IF(IHTG.EQ.1)HFI=-AK2-2.0D0*FI(1)*FI(2)
      IF(IHTG.EQ.2)HFITAU=FI(1)

      END Function HFI


      FUNCTION HR(J,H,R)
C R(1) IS THE WAVE REFLECTION COEFFICIENT AT THE HEIGHT H.R(2)
C IS ITS DERIVATIVE WITH RESPECT TO THE PROPAGATION CONSTANT P0(M).
C THESE SATISFY THE FIRST ORDER DIFFERENTIAL EQUATIONS DR(J)/DH
C =HR(J,H,R) WHERE J=1 OR 2 WHICH ARE INTEGRATED IN RUNKT2.
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16 HR,H,R(2),P,DP(4),F(5),G(5),HSTEP,AKI,TAU(1),HTAU,
     1HRTAU,D1P,D2P
      INTEGER  JF,I(12)
      COMMON /STEP/HSTEP,L /BUGGER/M,IDEBUG,AK,AK2,AKI /PEES/P,DP
      EQUIVALENCE(D1P,DP(1)),(D2P,DP(2))
      DATA JF/1/
      DATA I/1,3,3,5,1,2,2,3,3,4,4,5/
      IHTG=1
      GOTO 10
      ENTRY HTAU(J,H,TAU)
C TAU(1) IS THE HEIGHT-GAIN FUNCTION AT THE HEIGHT H.IT SATISFIES
C THE FIRST ORDER DIFFERENTIAL EQUATION DTAU(1)/DH=HTAU(1,H,TAU(1))
C WHEN THE WKB APPROXIMATION IS VALID.
      IHTG=2
      GOTO 10
      ENTRY HRTAU(J,H,R)
C R(1) IS THE WAVE REFLECTION COEFFICIENT AND R(2) THE HEIGHT-GAIN
C FUNCTION AT THE HEIGHT H.THESE SATISFY THE FIRST ORDER DIFFERENTIAL
C EQUATIONS DR/DH=HRTAU(J,H,R) WHERE J=1 OR 2 WHICH ARE INTEGRATED IN
C RUNKT2.
      IHTG=3
C ALL VALUES OF P AND D1P FOR TWO STEPS OF THE RUNGE-KUTTA METHOD
C ARE COMPUTED IN THE FIRST CALL TO HR OR HTAU.
   10 IF(JF.GT.1.OR.J.EQ.2) GOTO(80,90),J
      IF(L)20,30,50
C     IF(IDEBUG.EQ.3)PRINT*,'HR-H',H
   20 CALL PFUNCS(1,H)
      F(1)=CDSQRT(P)
      G(1)=D1P/P
      GOTO 40
   30 F(1)=F(5)
      G(1)=G(5)
   40 NM=1
      GOTO 60
   50 F(5)=F(3)
      F(3)=F(2)
      G(5)=G(3)
      G(3)=G(2)
      JF=5
      NM=2
   60 DO 70 N=1,4,NM
        CALL PFUNCS(1,(H+(0.5D0*N*HSTEP)))
        F(N+1)=CDSQRT(P)
   70 G(N+1)=D1P/P
C COMPUTE HR(1,H,R) IF IHTG=1 OR 3.COMPUTE HTAU(1,H,TAU) IF IHTG=2.
   80 NF=I(JF)
C     PRINT*,'R(1)',R(1),'F(NF)',F(NF),'G(NF)',G(NF),NF
      IF(IHTG.NE.2)HR=-2.D0*AKI*F(NF)*R(1)+.25D0*G(NF)*(1.0D0-R(1)*R(1))
      IF(IHTG.EQ.2)HTAU=-AKI*F(NF)-0.25D0*G(NF)
C     PRINT*,'HR',HR
      JF=JF+1
      IF(JF.GE.13)JF=1
      RETURN
C COMPUTE HR(2,H,R) IF IHTG=1 OR HRTAU(2,H,R) IF IHTG=3.
   90 IF(IHTG.EQ.1)HR=-AKI*(R(1)/F(NF)+2.0D0*F(NF)*R(2))-G(NF)*(0.25D0*
     1 (1.0D0-R(1)*R(1))/(F(NF)*F(NF))+0.5D0*R(1)*R(2))
      IF(IHTG.EQ.3)HRTAU=AKI*F(NF)*(1.0D0-R(1))/(1.0D0+R(1))

      END FUNCTION HR


      SUBROUTINE EIGEN(M,PSI0,DEL,SC,D1P0)
C EIGEN COMPUTES THE PROPAGATION CONSTANT P0(M) AND EXCITATION
C FACTOR FID(M) FOR THE M TH MODE.
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX*16 AK23,H1(9),P0(9),HA,P,DP(4),HB,D2P,FAC,FAC1,FIA(2),HFI,
     1FIB(2),RB(2),HR,R0(2),PSI0,DP0,FID(9),AKI,F,DF,R03,DDF,DDP0,D1P
      COMMON /BUGGER/N,IDEBUG,AK,AK2,AKI /PEXCIT/P0,FID /PEES/P,DP
     1 /TURNPT/H1
      EXTERNAL HFI,HR
      EQUIVALENCE(D1P,DP(1)),(D2P,DP(2))
C COMPUTE AN APPROXIMATE VALUE FOR P0(M).
      CALL PSTART(M,PSI0,DEL,SC,D1P0,H1)
C COMPUTE THE TURNING POINT H1.
      DO 20 ITER=1,9
        CALL TPOINT(DEL,SC,M,P0,H1)
C COMPUTE THE HEIGHT HA AT WHICH THE NUMERICAL INTEGRATION OF
C THE DIFFERENTIAL EQUATIONS IS TO BEGIN
C***********************************************************************
C THE FOLLOWING IF BLOCK IS REQUIRED BECAUSE THE CONCEPT OF EFFECTIVE
C EARTH'S RADIUS BREAKS DOWN AT LOW FREQUECIES (WITH DELTA=315.E-6 AND
C HSCALE=7.35KM MUST HAVE FREQUENCY >2.81E3 HERTZ FOR D1P0>0.0).
C                                                 RSGILL 19/9/85.
      IF(D1P0.GT.0.0D0)THEN
         AK23=(D1P0*AK2)**(-0.3333333)*(0.5D0,-0.8660254D0)             JPB
      ELSE
         AK23=(3.14D-7*AK2)**(-0.3333333)*(0.5D0,-0.8660254D0)          JPB
      END IF
C***********************************************************************
CTHE EXPRESSION BELOW FOR AK23 IS NOT CORRECT,BUT IS USED BY THE BOULDER
C AND GENEVA PEOPLE
C    10  AK23=(3.185E6/AK2)**.3333333*(.5,-.8660254)
        HA=H1(M)+5.0D0*AK23                                             JPB
C COMPUTE THE WAVE IMPEDANCE FIA(1) AND ITS DERIVATIVE WITH RESPECT
C TO P0(M) FIA(2) AT THE HEIGHT HA USING WKB APPROXIMATIONS
        CALL PFUNCS(1,HA)
        FAC=-AKI*CDSQRT(P)
        FAC1=-0.25D0*D1P/P                                              JPB
        FIA(1)=FAC+FAC1
        FIA(2)=(0.5D0*FAC-FAC1)/P                                       JPB
C COMPUTE THE HEIGHT HB AT WHICH THE INTEGRATION METHOD CHANGES
        HB=H1(M)-0.5D0*AK23                                             JPB
        IF(IDEBUG.EQ.2)WRITE(6,1000)HA,HB,H1(M)
 1000 FORMAT(' HA=(',E14.7,',',E14.7,')   HB=(',E14.7,',',E14.7,
     1')   H1=(',E14.7,',',E14.7,')' /'HR-1107')
C INTEGRATE THE DIFFERENTIAL EQUATIONS FROM HA TO HB.
        CALL RUNKT2(HFI,FIA,FIB,HA,HB,1.D-11,0.1D0,2,MSTEP)             JPB
        IF(IDEBUG.EQ.2)WRITE(6,2000)FIA,FIB,MSTEP
 2000 FORMAT(' FIA=',4E14.7,' FIB=',4E14.7,' MSTEP=',I3 /' HR-1112')
C COMPUTE THE REFLECTION COEFFICIENT RB(1) AND ITS DERIVATIVE RB(2)
C AT HB.
        CALL PFUNCS(1,HB)
        FAC=AKI*CDSQRT(P)
        FAC1=FAC+FIB(1)
        RB(1)=(FAC-FIB(1))/FAC1
        RB(2)=FAC*(FIB(1)/P-2.0D0*FIB(2))/(FAC1*FAC1)
C INTEGRATE FROM HB TO 0.
        CALL RUNKT2(HR,RB,R0,HB,(0.0D0,0.0D0),1.D-11,0.25D0/M,2,MSTEP)  JPB
        IF(IDEBUG.EQ.2)WRITE(6,3000)RB,R0,MSTEP
 3000 FORMAT(' RB =',4E14.7,' R0 =',4E14.7,' MSTEP=',I3 /' HR-1123')
C COMPUTE A NEW VALUE OF P0(M) USING NEWTONS METHOD.
        FAC=CDSQRT(P0(M))
        FAC1=FAC+PSI0
        F=R0(1)-(FAC-PSI0)/FAC1
        DF=R0(2)-PSI0/(FAC*FAC1*FAC1)
        R03=-0.375*(1.0D0-R0(1)*R0(1))/(P0(M)*P0(M))+R0(2)/R0(1)*(R0(2)
     1    -0.25D0*(1.0D0-R0(1))*(1.0D0-R0(1))/P0(M))
        FAC1=FAC1*FAC
        DDF=R03+PSI0*(PSI0+3.0D0*FAC)/(2.0D0*FAC1*FAC1*FAC1)
        DP0=-F/DF
        DDP0=-0.5D0*DP0*DP0*DDF/DF
        P0(M)=P0(M)+DP0+DDP0
        ERR=ABS2(DDP0/P0(M))
        IF(IDEBUG.EQ.2)WRITE(6,4000)ITER,ERR,DP0,DDP0,M,P0(M)
 4000 FORMAT(' ITER=',I1,'   ERR=',E15.7/' DP0=(',E14.7,',',E14.7,
     1')   DDP0=(',E14.7,',',E14.7,')   P0(',I1,')=(',E14.7,',',E14.7,
     2')' /' HR-1138')
        IF(ERR.LT.1.D-9)GOTO 30
   20   CONTINUE
      IF(IDEBUG.GE.1)WRITE(6,5000)
 5000 FORMAT(' NO CONVERGENCE IN EIGEN' ' HR-1144')
      STOP
   30 CALL PFUNCS(1,(0.0D0,0.0D0))
      FAC=CDSQRT(P0(M))
      R0(1)=(FAC-PSI0)/(FAC+PSI0)
      R0(2)=R0(2)+(DP0+DDP0)*R03
      FID(M)=AKI/(1.0D0+R0(1))*(0.5D0*(1.0D0-R0(1))/FAC-2.0D0*FAC*R0(2)/JPB
     1   (1.0D0+R0(1)))

      END SUBROUTINE EIGEN


      SUBROUTINE NEWHTG(M,HA,HB,FI,HTG)
C HTG IS THE LOGARITHMIC OF THE HEIGHT-GAIN FUNCTION.
C FI IS THE WAVE IMPEDANCE.
C GIVEN FI  AND HTG AT HA THE
C FIRST ORDER DIFFERENTIAL EQUATIONS FOR FI AND HTG ARE
C INTEGRATED IN RUNKT2 TO GIVE FI AND HTG AT HB. IF HB IS GREATER
C THAN HCH(M) ONLY THE WKB APPROXIMATION TO HTG IS GIVEN AT HB.
C HCH(M) IS THE MINIMUM HEIGHT AT WHICH THE WKB APPROXIMATION CAN BE
C USED AND IS COMPUTED IN PSTART.
C**********************************************************************
C*IF SUBROUTINE NEWHTG FAILS TO COMPUTE THE HEIGHT-GAIN FUNCTION THEN:*
C*   1. REDUCE THE STEPIN SIZE IN RUNKT2(HFITAU, , , , ,STEPIN, , )   *
C*      WHICH IS CALLED BELOW.STEPIN SATIFY THE INEQUILITY            *
C*            2*10-4<STEPIN<0.5                                       *
C*   2.  IF THAT FAILS USE ONE OF THE OTHER HEIGHT-GAIN SUBROUTINES   *
C*       (HEIGHT OR GHIGHT ) IN RESIDH.                               *
C**********************************************************************
      IMPLICIT REAL *8(A-H,O-Z)
      COMPLEX*16 HAC/(0.D0,0.D0)/,HBC/(0.D0,0.D0)/,FI,HTG,HTGI(1),HTGF(1
     1 ),HCHC,FII(2),FIF(2),HTAU,HFITAU,AKI
      COMMON /HCHITE/HCH(9) /BUGGER/N,IDEBUG,AK,AK2,AKI
      EXTERNAL HTAU,HFITAU
      HAC=DCMPLX(HA,0.0D0)
      HBC=DCMPLX(HB,0.0D0)
      IF(IDEBUG.EQ.2)PRINT*,'HAC=',HAC,'HBC=',HBC,'HCH(M)=',HCH(M),'M=',
     1 M ,'NEWHTG-1179'
      IF(HCH(M).GT.HA)GO TO 2
      HTGI(1)=HTG
      CALL RUNKT2(HTAU,HTGI,HTGF,HAC,HBC,1.D-10,0.125D0,1,MSTEP)
      HTG=HTGF(1)
      RETURN
   2  HCHC=HCH(M)
      FII(1)=FI
      FII(2)=HTG
      IF(HCH(M).GT.HB)GO TO 4
      CALL RUNKT2(HFITAU,FII,FIF,HAC,HCHC,1.D-10,0.001D0,2,MSTEP)       JPB
      FI=FIF(1)
      HTGI(1)=FIF(2)
      CALL RUNKT2(HTAU,HTGI,HTGF,HCHC,HBC,1.D-10,0.125D0,1,MSTEP)       JPB
      HTG=HTGF(1)
      RETURN
   4  CALL RUNKT2(HFITAU,FII,FIF,HAC,HBC,1.D-10,0.001D0,2,MSTEP)        JPB
      FI=FIF(1)
      HTG=FIF(2)

      END SUBROUTINE NEWHTG


      SUBROUTINE HEIGHT(M,HA,HB)
C HTG IS THE HEIGHT-GAIN FUNCTION OR LOGARITHM OF THE WAVE FUNCTION.
C FI IS THE WAVE IMPEDANCE. R IS THE WAVE REFLECTION COEFFICIENT. FI IS
C USED ABOVE HCC. R IS USED BELOW HCC. GIVEN FI (OR R) AND HTG AT HA THE
C FIRST ORDER DIFFERENTIAL EQUATIONS FOR FI (OR R) AND HTG ARE
C INTEGRATED IN RUNKT2 TO GIVE FI (OR R) AND HTGAT HB. IF HB IS GREATER
C THAN HCH(M) ONLY THE WKB APPROXIMATION TO HTG IS GIVEN AT HB.
C
C***********************************************************************
C*IF HEIGHT FAILS TO COMPUTE THE HEIGHT-GAIN FUNCTION THEN :           *
C*      1.   REDUCE THE STEPIN SIZE IN RUNKT2(HRTAU, , , , , ,STEPIN,,)*
C*              AND IN RUNKT2(HFITAU, , , , , , STEPIN, , ,)           *
C*             WHICH ARE CALLED BELOW.STEPIN SATISFY THE INEQUILITY:   *
C*                     2*10-4<STEPIN<0.5                               *
C*      2.  IF THAT FAILS USE ONE OF THE OTHER HEIGHT-GAIN SUBROUTINES *
C*           (NEWHTG OR GHIGHT IN RESIDH.)                             *
C*      3. IF BOTH 1 AND 2 FAILS THEN TAKE A WALK!                     *
C***********************************************************************
C THIS SUBROUTINE CAN BE USED INSTEAD OF SUBROUTINE NEWHTG IN RESIDH
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16 HAC,HBC,FI,HTG,HTGI(1),HTAU,HTGF(1),HCHC,FII(2),
     1HFITAU,FIF(2),HCC,H1(9),HRTAU,AKI,P,R,FAO,Y,DP(4)
      COMMON/BUGGER/N,IDEBUG,AK,AK2,AKI /HTGAIN/FI,HTG/HCHITE/HCH(9)
     1/TURNPT/H1 /PEES/P,DP
      EQUIVALENCE (FI,R,FIF(1)),(HTG,HTGF(1))
      EXTERNAL HTAU,HFITAU,HRTAU
      HAC=DCMPLX(HA,0.0D0)
      HBC=DCMPLX(HB,0.0D0)
      HC=DREAL(H1(M))
      HCC=DCMPLX(HC,0.0D0)
      HCHC=DCMPLX(HCH(M),0.0D0)
      FII(1)=FI
      FII(2)=HTG
      IF(HA.LT.HC)GO TO 10
      IF(HA.LT.HCH(M))GO TO 40
      HTGI(1)=HTG
      CALL RUNKT2(HTAU,HTGI,HTGF,HAC,HBC,1.D-10,0.125D0,1,MSTEP)
      RETURN
   10 IF(HB.GT.HC)GO TO 20
      CALL RUNKT2(HRTAU,FII,FIF,HAC,HBC,1.D-10,0.01D0,2,MSTEP)
      RETURN
   20 CALL RUNKT2(HRTAU,FII,FIF,HAC,HCC,1.D-10,0.01D0,2,MSTEP)
      CALL PFUNCS(0,HCC)
      FII(1)=AKI*CDSQRT(P)*(1.0D0-R)/(R+1.0D0)
      FII(2)=FIF(2)
      IF(HB.GT.HCH(M))GO TO 30
      CALL RUNKT2(HFITAU,FII,FIF,HCC,HBC,1.D-10,0.001D0,2,MSTEP)
      RETURN
 30   CALL RUNKT2(HFITAU,FII,FIF,HCC,HCHC,1.D-10,0.001D0,2,MSTEP)
      HTGI(1)=FIF(2)
      CALL RUNKT2(HTAU,HTGI,HTGF,HCHC,HBC,1.D-10,0.125D0,1,MSTEP)
      RETURN
   40 IF(HB.LT.HCH(M))GO TO 50
      HCC=HAC
      GO TO 30
   50 CALL RUNKT2(HFITAU,FII,FIF,HAC,HBC,1.D-10,0.001D0,2,MSTEP)

      END SUBROUTINE HEIGHT


      SUBROUTINE GHIGHT(M,HA,HB)
C HTG IS THE HEIGHT-GAIN FUNCTION OR LOGARITHM OF THE WAVE FUNCTION.
C R IS THE WAVE REFLECTION COEFFICIENT.
C GIVEN  R AND HTG AT HA THE
C FIRST ORDER DIFFERENTIAL EQUATIONS FOR  R AND HTG ARE
C INTEGRATED IN RUNKT2 TO GIVE FI (OR R) AND HTGAT HB. IF HB IS GREATER
C THAN HCH(M) ONLY THE WKB APPROXIMATION TO HTG IS GIVEN AT HB.
C
C THIS SUBROUTINE CAN BE USED INSTEAD OF NEWHTG IN RESIDH.
C***********************************************************************
C*IF SUBROUTINE GHIGHT FAILS TO COMPUTE THE HEIGHT-GAIN FUNCTION THEN  *
C*   1. REDUCE THE STEPIN SIZE IN RUNKT2(HRTAU, , , , )WHICH IS CALLED *
C*       BELOW.STEPIN SATIFY THE INEQUILITY                            *
C*        2*10-4<STEPIN<0.5                                            *
C*   2. IF 1 FAILS THEN USE ONE OF THE OTHER HEIGHT-GAIN SUBROUTINES   *
C*        (HEIGHT OR NEWHTG) IN RESIDH.                                *
C***********************************************************************
      IMPLICIT REAL *8(A-H,O-Z)
      COMPLEX*16 HAC/(0.D0,0.D0)/,HBC/(0.D0,0.D0)/,R,HTG,HTGI(1),
     1HTGF(1),HCHC,FII(2),FIF(2),HTAU,HRTAU,FI,AKI
      COMMON /HTGAIN/R,HTG /HCHITE/HCH(9) /BUGGER/N,IDEBUG,AK,AK2,AKI
      EQUIVALENCE (R,FIF(1)),(HTG,HTGF(1))
      EXTERNAL HTAU,HRTAU
      HAC=DCMPLX(HA,0.0D0)
      HBC=DCMPLX(HB,0.0D0)
      IF(HCH(M).GT.HA)GO TO 2
      HTGI(1)=HTG
      CALL RUNKT2(HTAU,HTGI,HTGF,HAC,HBC,1.D-10,.125D0,1,MSTEP)         JPB
      RETURN
   2  HCHC=HCH(M)
      FII(1)=R
      FII(2)=HTG
      IF(HCH(M).GT.HB)GO TO 4
      CALL RUNKT2(HRTAU,FII,FIF,HAC,HCHC,1.D-10,0.01D0,2,MSTEP)         JPB
      HTGI(1)=FIF(2)
      CALL RUNKT2(HTAU,HTGI,HTGF,HCHC,HBC,1.D-10,.125D0,1,MSTEP)        JPB
      RETURN
   4  CALL RUNKT2(HRTAU,FII,FIF,HAC,HBC,1.D-10,0.01D0,2,MSTEP)          JPB

      END SUBROUTINE GHIGHT


      SUBROUTINE SORT(A,B,I,J)
C SORT ARRANGES THE ARRAY A IN ASCENDING ORDER IN B.THE L TH ELEMENT
C OF B THEN COMES FROM THE I(L) TH ELEMENT OF A.A,B AND I HAVE
C DIMENSION J.
C
C SORT IS CALLED BY RESIDH
C
      IMPLICIT REAL *8(A-H,O-Z)
      DIMENSION A(J),B(J),I(J)
C
      DO 10 L=1,J
        B(L)=A(L)
   10   I(L)=L
      DO 30 L=1,J
        SMALL=B(L)
        IS=L
      DO 20 N=L,J
          IF(B(N).GE.SMALL)GOTO20
          SMALL=B(N)
          IS=N
   20 CONTINUE
          B(IS)=B(L)
          B(L)=SMALL
          IPS=I(IS)
          I(IS)=I(L)
   30     I(L)=IPS

      END SUBROUTINE SORT


      SUBROUTINE RESIDH(IALT,DEL,SC,D1P0,PSI0,DMIN,DMAX,DSTEP
     1 ,LOGLIN,JR,JT,LRMIN,LTMIN,HR,HT,DM,DA,EDBA,TL,NA)
C RESIDH COMPUTES THE FIELD STRENGTH-DISTANCE VARIATIONS USING THE
C RESIDUE SERIES FOR ELEVATED TERMINALS.
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 DA(100),EDBA(100),TL(100),HRS(20),HTS(20) , HR(20),HT(20),
     1 DM(20,20),Y
      INTEGER IR(20),IT(20)
      COMPLEX*16 P0(9),FI,FID(9),HTG,AKI,PSI0,SM1(9),AITKEN(9),BC,EXC(9)
     1 ,HTGR(9,20),HTGT(9,20),TERMLG,TERM(9),SERIES(9),P0SUB(9),R, RR(9,
     2 20),FIR(9,20),RT(9,20),FIT(9,20)
      COMMON/BUGGER/M,IDEBUG,AK,AK2,AKI/PEXCIT/P0,FID/HTGAIN/R,HTG
     1/HCHITE/HCH(9)/BROCK/HTU(20),HRU(20),FREQ,TLC,IPOLRN
C**********************************************************************
C COMMON BLOCK HTGAIN IS REQUIRED BY SUBROUTINES HEIGHT AND GHIGHT.THESE
C SUBROUTINES CAN BE USED INSTEAD OF NEWHTG TO COMPUTE THE HEIGHT-GAIN
C FUNCTION.
C***********************************************************************
C     All height gain factors are computed on first call only (IALT=1)
      IF(IALT.GE.2) GOTO 110                                            jfc
C
C COMPUTE THE PROPAGATION CONSTANTS P0(M) AND EXCITATION FACTORS
C FID(M) (M=1,9)
      DO 10 M=1,9
        CALL EIGEN (M,PSI0,DEL,SC,D1P0)
        P0SUB(M)=P0(M)
        SM1(M)=AKI*(DEL-P0(M))/(CDSQRT(1.0D0+DEL-P0(M))+1.0D0)
   10   EXC(M)=CDLOG(-2.0D0*FID(M)*(1.0D0+SM1(M)/AKI))
      IF(IDEBUG.EQ.2)WRITE(6,1000)(M,P0(M),SM1(M),FID(M),HCH(M),M=1,9)
 1000 FORMAT('0M',20X,'P0',35X,'SM1',34X,'FID',24X,'HCH',9(/1X,I1,3(6X,
     1'(',E14.7,',',E14.7,')'),E17.7) /' RESIDH-1354')
   20 DO 30 M=1,9
   30   P0(M)=P0SUB(M)
C THE REFERENCE DIPOLE HAS A FIELD OF 150.0 MILLIVOLTS/M AT 1 KM IN
C FREE SPACE
   40 A=0.5D0*DLOG(8.877D10*AK*AK2)
      AITKEN(1)=(0.0D0,0.D0)                                            JPB
      AITKEN(2)=(0.0D0,0.D0)                                            JPB
C SORT THE TERMINAL HEIGHTS INTO ASCENDING ORDER.
      CALL SORT(HR,HRS,IR,JR)
      CALL SORT(HT,HTS,IT,JT)
C COMPUTE THE HEIGHT GAIN FUNCTIONS.
      DO 90 M=1,9
C THE BOUNDARY CONDITION AT THE SURFACE (H=0) FOR THE RECIPROCAL OF THE
C REFLECTION COEFFICIENT (R),HEIGHT GAIN FN (HTG) AND THE WAVE IMPEDENCE
C (FI) ARE :
        R=1.0D0-2.0D0*PSI0/(PSI0+CDSQRT(P0(M)))
C*********************************
        FI=AKI*PSI0
C*********************************
        HTG=(0.0D0,0.D0)                                                JPB
        HSUB=0.0D0
        LT=1
        LR=1
   50   IF(HTS(LT).LT.HRS(LR))GOTO 70
C***********************
C SUBROUTINE NEWHTG IS USED TO COMPUTE THE HEIGHT GAIN FUNCTION.HOWEVER
C SUBROUTINE HEIGHT OR SUBROUTINE GHIGHT CAN BE USED INSTEAD.THEN MUST
C ALSO INCLUDE COMMON/HTGAIN/R,HTG/ .
C*******************************************************************
C  60   IF(HSUB.NE.HRS(LR))CALL NEWHTG(M,HSUB,HRS(LR),FI,HTG)
   60   IF(HSUB.NE.HRS(LR))CALL HEIGHT(M,HSUB,HRS(LR))
C  60   IF(HSUB.NE.HRS(LR))CALL GHIGHT(M,HSUB,HRS(LR))
C************************
        HSUB=HRS(LR)
        L=IR(LR)
        FIR(M,L)=FI
        HTGR(M,L)=HTG
        LR=LR+1
        GOTO 80
C*************************
C  70   IF(HSUB.NE.HTS(LT))CALL NEWHTG(M,HSUB,HTS(LT),FI,HTG)
   70   IF(HSUB.NE.HTS(LT))CALL HEIGHT(M,HSUB,HTS(LT))
C  70   IF(HSUB.NE.HTS(LT))CALL GHIGHT(M,HSUB,HTS(LT))
C********************
        HSUB=HTS(LT)
        L=IT(LT)
        FIT(M,L)=FI
        HTGT(M,L)=HTG
        LT=LT+1
   80   IF(LR.LE.JR.AND.LT.LE.JT)GOTO 50
        IF(LR.LE.JR.AND.LT.GT.JT)GOTO 60
        IF(LT.LE.JT)GOTO 70
   90   CONTINUE
      IF(IDEBUG.LE.1)GOTO 110
C     PRINT*,'RESIDH-1408' 
      DO 100 M3=1,3
        M2=3*M3
        M1=M2-2
        IF(IDEBUG.EQ.2.AND.IALT.EQ.1)WRITE(6,2000)(M,M=M1,M2)
 2000 FORMAT('0LR',7X,'HR(LR)',3(17X,'HTGR(',I1,',LR)',7X)
     1  ' RESIDH-1413')
C************************
        IF(IDEBUG.EQ.2.AND.IALT.EQ.1)WRITE(6,3000)(LR,HR(LR),(HTGR(M,
     1   LR),M=M1,M2),LR=1,JR)
 3000 FORMAT((I3,E17.7,3(3X,'(',E14.7,',',E14.7,')'))
     1  ' RESIDH-1417,1425')
        IF(IDEBUG.EQ.2.AND.IALT.EQ.1)WRITE(6,4000)(M,M=M1,M2)
 4000 FORMAT('0LT',7X,'HT(LT)',3(17X,'HTGT(',I1,',LT)',7X)
     1  ' RESIDH-1421')
C****************
  100   IF(IDEBUG.EQ.2.AND.IALT.EQ.1)WRITE(6,3000)(LT,HT(LT),(HTGT(M,
     1   LT),M=M1,M2),LT=1,JT)
C
C COMPUTE THE RESIDUE SERIES FOR EACH OF THE HEIGHT COMBINATIONS
C BEGINNING AT A DISTANCE OF DMAX AND MOVING INWARDS TO DMIN OR
C UNTIL THE CONVERGENCE FAILS.
  110 LR=LRMIN
      LT=LTMIN
      TLC=BTLC(HTU(LT),HRU(LR),1D6*FREQ,IPOLRN)                         JPB
      NAF=0
      NA=100
      DA(NA)=DMAX
C CHECK THAT DMAX IS IN RESIDUE SERIES ZONE.
      DH=(5.7565D0+DREAL(HTGR(9,LR)+HTGT(9,LT)-EXC(9)-HTGR(1,LR)-HTGT(1,JPB
     1 LT)+EXC(1)))/(1000.0D0*DREAL(SM1(9)-SM1(1)))                     JPB
      IF(IDEBUG.GE.1) PRINT*,'DH',DH ,'RESIDH-1140'
      IF(DMAX.GT.DH)GOTO 120
      IF(IDEBUG.GE.1)WRITE(6,5000)DMAX,DH
 5000   FORMAT(' DMAX=',E15.7,' IS LESS THAN DH=',E15.7, ' RESIDH-1142')
  120 DO 150 M=1,9
        TERMLG=-1.E3*DA(NA)*SM1(M)+HTGR(M,LR)+HTGT(M,LT)-EXC(M)+A
        IF(IDEBUG.EQ.2)WRITE(6,6000)M,NAF,NA,DA(NA),TERMLG
 6000 FORMAT(' M=',I2,' NAF=',I1,' NA=',I3,' DA  =',E14.7,
     1' TERMLG=(',E14.7,',',E14.7,')' ' RESIDH-1446')
C IF THE TERM OF THE RESIDUE SERIES IS TOO LARGE MOVE TO NEXT HEIGHT.
        IF(DREAL(TERMLG).LT.50.0D1)GOTO 130                             JPB
        IF(IDEBUG.GE.1)WRITE(6,7000)
 7000 FORMAT('0TERM OF RESIDUE SERIES TOO BIG.DECREASE DSTEP'
     1  ' RESIDH-1451')
        IF(NA.EQ.100)GOTO 250
        NA=NA+1
        GOTO 240
C IF THE TERM OF THE RESIDUE SERIES IS TOO SMALL INCREMENT DA.
  130   IF(DREAL(TERMLG).GT.-50.0D1)GOTO 140                            JPB
        IF(IDEBUG.GE.1)PRINT*,
     1   'TERMS OF THE RESIDUE SERIES IS TOO SMALL   DECREASE DA'
     2  ,'RESIDH-1459'
        IF(LOGLIN.EQ.0)DA(NA)=DA(NA)-DSTEP
        IF(LOGLIN.EQ.1)DA(NA)=DA(NA)/DSTEP
        GOTO 200
C COMPUTE THE TERMS,TERM(M),AND PARTIAL SUMS,SERIES(M),OF THE
C RESIDUE SERIES.
  140   TERM(M)=CDEXP(TERMLG)
        IF(M.EQ.1)SERIES(1)=TERM(1)
        IF(M.NE.1)SERIES(M)=SERIES(M-1)+TERM(M)
C TEST FOR CONVERGENCE.
        EPS6=ABS2(TERM(M)/SERIES(M))
        IF(IDEBUG.EQ.2)WRITE(6,8000)M,EPS6,TERM(M),SERIES(M)
 8000 FORMAT(' M=',I2,3X,'EPS6=',E14.7,' TERM  =(',E14.7
     1,',',E14.7,') SERIES=(',E14.7,',',E14.7,')  RESIDH-1472')
        IF(ABS2(TERM(M)/SERIES(M)).LT.1.D-5)GOTO170                     JPB
C ACCELERATE THE CONVERGENCE USING AITKEN EXTRAPOLATION.
        IF(M.LT.2)GOTO 150
        AITKEN(M)=SERIES(M)-TERM(M)*TERM(M)/(TERM(M)-TERM(M-1))
C TEST FOR CONVERGENCE.
        EPS=ABS2(1.0D0-AITKEN(M-1)/AITKEN(M))
        IF(IDEBUG.EQ.2)WRITE(6,9000)M,EPS,AITKEN(M)
 9000 FORMAT(' M=',I2,3X,'EPS =',E14.7,' AITKEN=(',E14.7,',',E14.7
     1,') RESIDH-1481')
        IF(EPS.LT.1.D-5)GOTO 180                                        JPB
  150   CONTINUE
C THE RESIDUE SERIES HAS CONVERGED AT DA(NA+1) BUT NOT AT DA(NA)
C COMPUTE THE DISTANCE AT WHICH THE CONVERGENCE THRESHOLD IS
C CROSSED,CALL THIS DA(NA) AND RECOMPUTE THE FIELD.SET NAF=1 TO
C SIGNIFY THAT THIS HAS HAPPENED.
      M=9
C*****************
      IF(DA(NA).EQ.DMIN)GOTO 220
C*****************
      IF(DA(NA).LT.DH.AND.DMAX.LT.DH)GOTO 210
C*****************************
      IF(NAF.EQ.1)GOTO 180
      DPLUS=DLOG(1.D5*EPS)/(2000.0D0*DREAL(SM1(9)-SM1(1)))              JPB
      IF(EPS.LT.2.D-5.AND.DPLUS.LT.(DA(NA+1)-DA(NA)))GOTO160            JPB
      DA(NA)=DA(NA)+0.5D0*DMIN1(DPLUS,DA(NA+1)-DA(NA))
C ******************
      IF(DMAX.LT.DH.AND.DMAX.LE.DA(NA))GOTO 250
C******************
      NAF=2
      IF(IDEBUG.GE.1)PRINT*,'NA',NA,'DA',DA(NA),'NAF',NAF,'DA(NA+1)',
     1 DA(NA+1) ,'RESIDH-1504'
      GOTO 200
  160 DA(NA)=DA(NA)+DPLUS
C**************
      IF(DMAX.LT.DH.AND.DMAX.LE.DA(NA))GOTO 250
C**************
      DM(LR,LT)=DA(NA)
      NAF=1
      GOTO 200
C***********************
C COMPUTE THE FIELD EDBA(NA) IN DB ABOVE 1 MICROVOLT/M.
  170 BC=SERIES(M)
      GOTO 190
  180 BC=AITKEN(M)
  190 EDBA(NA)=10.0D0*DLOG10(ABS2(BC)/DSIN(DA(NA)*1.57D-4))             JPB
      IF(IDEBUG.EQ.2)WRITE(6,10000)M,EDBA(NA),BC
10000 FORMAT(' M=',I2,13X,'EDB =',E14.7,' BC    =(',E14.7,',',E14.7
     1,')' ' RESIDH-1520')
      TL(NA)=TLC-EDBA(NA)
      IF(NAF.GE.1.OR.NA.LE.1.OR.DA(NA).LE.DMIN)GOTO 230
C COMPUTE THE NEXT RANGE DA(NA).
      NA=NA-1
      IF(LOGLIN.EQ.0)DA(NA)=DA(NA+1)-DSTEP
      IF(LOGLIN.EQ.1)DA(NA)=DA(NA+1)/DSTEP
  200 IF(DA(NA).GE.DMIN)GOTO 120
      IF(DA(NA).LT.DMIN)DA(NA)=DMIN
      NAF=1
      GO TO 120
C PRINT RESULTS.
C**********************
  210 DM(LR,LT)=DA(NA)
      EDBA(NA)=0.0D0
      TL(NA)=0.0D0
      GOTO 240
  220 NA=NA+1
      DM(LR,LT)=DA(NA)
      IF(IDEBUG.GE.1)PRINT*,'DA',DA(NA),'DM=',DM(LR,LT),'LR',LR,'LT',LT
     1 ,'RESIDH-1541'
      GOTO 240
C******************
  230 DM(LR,LT)=DA(NA)
C*******************
  240 IF(IDEBUG.GE.1)WRITE(6,11000)HT(LT),HR(LR),(DA(N1),EDBA(N1), N1=
     1 NA,100 )
11000 FORMAT(////' RESIDUE SERIES ZONE      HT=',E15.7,6X,'HR=',
     1E15.7/6X,'RANGE',14X,' FIELD STRENGH'/8X,'KM',15X,'DB ABOVE ',
     2'1 MICROVOLT/M'/(1X,E14.7,E24.7) ' RESIDH-1547')


 250  END SUBROUTINE RESIDH


      FUNCTION W(Z)
C......................................................................
C REVISED VERSION CODED SEPTEMBER 1988 PER UPDATE INFORMATION FROM CCIR
C SECRETARIAT. CORRECT FOR LACK OF CONVERGENCE OF THE ASSYPTOTIC SERIES
C NEAR THE ORIGIN.
C .....................................................................
C
C W(Z)=EXP(-Z**2)*ERFC(-I*Z)
C
C W(Z) IS USED IN JCALC
C
        IMPLICIT REAL *8(A-H,O-Z)
        COMPLEX *16 W,Z,A2,TERM,SUM,TEST,RA,RA2,FAC,AKI
        COMMON/BUGGER/M,IDEBUG,AK,AK2,AKI
        LOGICAL TYPE
        ZR=DREAL(Z)                                                     JPB
        ZI=DIMAG(Z)
        A2=Z*Z
        CZ=ZR*ZR+ZI*ZI
        TYPE=DABS(ZR).GT.DABS(ZI)                                       JPB
        IF(0.238 D0*DABS(ZR)+0.269D0*DABS(ZI).GT. 1.D0 .OR.
     1     0.3225D0*DABS(ZR)-0.37 D0*DABS(ZI).GT. 1.D0 .OR.
     2     0.090 D0*DABS(ZR)+0.4  D0*DABS(ZI).GT. 1.D0) THEN
            RA=1.0D0/Z
            IF(ZI.LT.0.0D0)RA=-RA
          RA2=RA*RA
            TERM=(0.0D0,0.5641896D0)*RA
            SUM=TERM
            TEST=SUM
            DO 10 M=1,40
            TERM=(M-0.5D0)*RA2*TERM
            SUM=SUM+TERM
            FAC=1.0D0/(A2-M-0.5D0)
            IF((2.0D0*M+1.0D0)*ABS2(FAC).LE.0.4D0) THEN
                  W=SUM+(M+0.5D0)*TERM*FAC*(1.0D0+A2*FAC*FAC)
               ELSE
                  W=SUM+TERM*(-1.0D0+A2*((0.0D0,0.5641896D0)/
     1            DSQRT(2.0*M+1.0D0)+(A2-M-0.5D0)/(M+0.5D0)))
               ENDIF
            IF(ABS2(1.0D0-TEST/W).LT.1.D-10) GOTO 20
10          TEST=W
            PRINT 3000,1,Z
            STOP
20          IF(TYPE.AND.DABS(ZR*ZI).LT.0.25D0)W=CDEXP(-A2)+W
            IF(ZI.LT.0.0D0)W=2.0D0*CDEXP(-A2)-W
      ELSE IF(CZ.EQ.0.0D0) THEN
                  W=(1.0D0,0.0D0)
      ELSE 
        TERM=(0.0D0,1.128379D0)*Z
        SUM=TERM
        W=SUM
        TEST=SUM
      DO 30 M=1,40
       IF(TYPE) THEN
          TERM=(M-0.5)/(M*(M+0.5))*A2*TERM
          SUM=SUM+TERM
          W=SUM
          IF(M.GE.CZ+2)THEN
              FAC=A2/(M+1.0D0-A2)
              W=W+(FAC*(1.0D0-FAC*FAC/(M+1.0D0))-1.0D0/(M+1.0D0))*TERM
            ENDIF
       ELSE
         TERM=-TERM*A2/(M+.5)
         SUM=SUM+TERM
         W=SUM
            IF(M.GE.CZ+2) THEN
              FAC=1.0D0/(M+1.5D0+A2)
              W=W-A2*TERM*FAC*(1.0D0+A2*FAC*FAC)
            ENDIF
        ENDIF
        IF(IDEBUG.GE.2)WRITE(6,2000)M,TERM,SUM,W
 2000   FORMAT(1X,I3,3(3X,'(',E14.7,',',E14.7,')'), ' W(Z)-1599,1627')
        IF(ABS2(1.0D0-TEST/W).LT.1.E-10)GOTO40
   30   TEST=W
        PRINT 3000,2,Z
      STOP
 3000   FORMAT(' NO CONVERGENCE IN W' ,' W(Z)-1603,1630')
   40   IF(TYPE) THEN
           W=CDEXP(-A2)*(1.0D0+W)
         ELSE  
           W=CDEXP(-A2)+W
         ENDIF
      ENDIF
        IF(IDEBUG.GE.2)WRITE(6,4000)W
 4000   FORMAT(' W=(',E14.7,',',E14.7,')',' W(Z)-1608,1634')

      END FUNCTION W


      SUBROUTINE JCALC(NMAX,TAU,J)
C JCALC COMPUTES A SET OF FUNCTIONS J(M) (M=1,MAX) WITH ARGUMENT TAU
C THE J(M) ARE DEFINED BY
C        J(1)=1  =EQUATION 82 SRIII
C        J(2)=(0.,1.772454)*W(TAU) =EQUATION 82 SRIII
C        J(M)=(TAU*J(M-1)+J(M-2))/(1.-.5*N)
C W(TAU) IS THE ERROR FUNCTION DEFINED IN ABRAMOWITZ AND STEGUN 7.1.3.
C
C JCALC=J(M);COMPUTES EQUATIONS 81 AND 82 SRIII
C
C JCALC IS CALLED BY FLATX3 AND JRCALC AND IT IN TURN USES W(Z)
C
C
      IMPLICIT REAL *8(A-H,O-Z)
      COMPLEX *16 TAU,J(17),W,A(34),B(17),FAC,RTAU,AKI
      COMMON /BUGGER/M,IDEBUG,AK,AK2,AKI
      EQUIVALENCE (A(18),B(1))
      EXTERNAL W
C COMPUTE J(1) AND J(2).
      J(1)=(1.0D0,0.0D0)
      J(2)=(0.0D0,1.772454)*W(TAU)
      IF(NMAX.EQ.2)GOTO70
C COMPUTE A(N) AND B(N) (N=1,NMAX) USING THE FORWARD RECURRENCE
C RELATION.
      A(1)=J(1)
      A(2)=(0.0D0,0.0D0)
      B(1)=(0.0D0,0.0D0)
      B(2)=J(2)
      DO 10 N=3,NMAX
        C=1.0D0/(1.0D0-0.5D0*N)
        A(N)=C*(TAU*A(N-1)+A(N-2))
   10   B(N)=C*(TAU*B(N-1)+B(N-2))
      IF(IDEBUG.EQ.2)WRITE(6,1000)(A(N),N=1,NMAX)
 1000 FORMAT(' A=',8E15.7/(3X,8E15.7) ' JCALC-1669,1692')
      IF(IDEBUG.EQ.2)WRITE(6,2000)(B(N),N=1,NMAX)
 2000 FORMAT(' B=',8E15.7/(3X,8E15.7) ' JCALC-1671')
C TEST FOR ROUNDING ERRORS.
      IF(ABS2(1.0D0+B(NMAX)/A(NMAX)).LT.1.E-5)GOTO30
C COMPUTE J(N) (N=3,NMAX).
      DO 20 N=3,NMAX
   20   J(N)=A(N)+B(N)
      GOTO70
C FOR LARGE TAU USE THE BACKWARD RECURRENCE RELATION.
   30 A(34)=(0.0D0,0.0D0)
      A(33)=(1.0D0,0.D0)
      FAC=0.5/(TAU*TAU)
      DO 40 N=1,32
        N1=33-N
   40   A(N1)=-A(N1+1)-N1*FAC*A(N1+2)
      FAC=1.0D0/A(1)
      RTAU=1.0D0/TAU
      DO 50 N=2,NMAX
        FAC=FAC*RTAU
   50   A(N)=FAC*A(N)
      A(1)=(1.0D0,0.0D0)
      IF(IDEBUG.EQ.2)WRITE(6,1000)(A(N),N=1,NMAX)
      DO 60 N=3,NMAX
   60   J(N)=A(N)
C PRINT RESULTS.
   70 IF(IDEBUG.EQ.2)WRITE(6,3000)TAU,(J(N),N=1,NMAX)
 3000 FORMAT(' TAU=(',E14.7,',',E14.7,')   J=',6E15.7/(11X,8E15.7)
     1  /' JCALC-1696')

      END SUBROUTINE JCALC


      SUBROUTINE JRCALC (TAUP,TAUR,JRP)
C JRCALC COMPUTES THE ARRAY JRP WHICH IS USED IN FLATX3.EACH ELEMENT
C IS A COMBINATION OF THE ERROR FUNCTIONS W(TAUP) AND W(TAUR).
C
C JRCALC COMPUTES EQUATIONS 83-90,APPENDIX 2 SRIII.
C JRP=M SUBSCRIPT MN AND ARGUMENT ALFA,BETA.
C IT COMPUTES M SUBSCRIPT A,B WHEN A=1,B=1,7.A=2,B=1,7.A=3,B=1,5.A=4,B=4
C
C JRCALC IS CALLED BY FLATX3 AND IT IN TURN CALLS JCALC
C
      IMPLICIT REAL *8(A-H,O-Z)
      LOGICAL LT
      COMPLEX *16 J(17),TAUP,TAUR,DT,JRP(4,7),FAC,TERM,RDT,AKI
      COMMON/BUGGER/MODENO,IDEBUG,AK,AK2,AKI
C DIFFERENT PROCEDURES ARE USED ACCORDING AS THE MODULUS OF
C (TAUP-TAUR) IS LESS THAN OR GREATER THAN .4.
C
C TAUR=TAU SUBSCRIPT R.SEE EQUATION 52 SRIII
C TAUP=TAU SUBSCRIPT S..............53......
C
      DO 10 M=1,7
      DO 10 N=1,4
   10  JRP(N,M)=(0.0D0,0.0D0)
      DT=TAUP-TAUR
      LT=ABS2(DT).LT.0.16D0
      IF(LT)GOTO40
C LARGE (TAUP-TAUR).COMPUTE JRP(1,M) (M=1,7) AND JRP(2,1) USING JCALC.
      CALL JCALC(2,TAUP,J)
      JRP(2,1)=J(2)
C
C JRP(2,1)=M SUBSCRIPT 2 (TAU S)
C
      CALL JCALC(7,TAUR,J)
      DO 20 M=1,7
   20   JRP(1,M)=J(M)
C
C THIS COMPUTES EQUATION 89 SR III
C
C USE THE RECURRENCE RELATION FORWARDS TO COMPUTE JRP(2,M) (M=2,6).
      RDT=1.0D0/DT
C
C RDT=1/(TAU S -TAU R)
C
      DO 30 M=2,6
   30  JRP(2,M)=RDT*(JRP(2,M-1)-JRP(1,M))
C
C EQUATION 85 SRIII
C
      GOTO90
C SMALL (TAUP-TAUR).COMPUTE JRP(1,M) (M=1,7) USING JCALC.COMPUTE
C JRP(2,6) FROM A SERIES IN POWERS OF (TAUP-TAUR).
   40 CALL JCALC(17,TAUR,J)
      DO 50 M=1,7
   50   JRP(1,M)=J(M)
      JRP(2,6)=J(7)
      FAC=(1.0D0,0.0D0)
      DO 60 N=8,17
        FAC=FAC*DT
        TERM=FAC*J(N)
        JRP(2,6)=JRP(2,6)+TERM
        IF(ABS2(TERM/JRP(2,6)).LT.1.D-10)GOTO70
   60 CONTINUE
      IF(IDEBUG.GE.1)WRITE(6,1000)
 1000 FORMAT(' JRP HAS NOT CONVERGED' ' JCALC-1763')
      STOP
C COMPUTE JRP(2,M) (M=1,5) FROM THE BACKWARDS RECURRENCE RELATION.
   70 DO 80 M=1,5
        M1=6-M
   80   JRP(2,M1)=JRP(1,M1+1)+DT*JRP(2,M1+1)
C COMPUTE JRP(3,M) (M=2,5) AND JRP(4,4) FROM THE FORWARD RECURRENCE
C RELATION.
   90 DO 100 M=2,5
  100   JRP(3,M)=-2.0D0*JRP(2,M-1)-2.0D0*TAUR*JRP(2,M)-(M-1)*JRP(2,M+1)
C
C EQUATION 84 SRIII
C
      JRP(4,4)=-JRP(3,3)-TAUR*JRP(3,4)-1.5D0*JRP(3,5)
C COMPUTE JRP(2,0).PLACE IN JRP(2,7).
      JRP(2,7)=JRP(1,1)+DT*JRP(2,1)
C PRINT RESULTS.
      IF(IDEBUG.EQ.2)WRITE(6,2000)(JRP(2,M),M=1,7),(JRP(3,M),M=2,5),JRP(
     1 4,4 )
 2000 FORMAT(' JRP=',8E15.7/(5X,8E15.7) /' JCALC-1781')

      END SUBROUTINE JRCALC


      SUBROUTINE YCALC (HLC,HHC,YD,YR)
C YCALC COMPUTES ARRAYS YD AND YR.THESE ARE USED IN FLATX3.
      IMPLICIT REAL *8(A-H,O-Z)
      LOGICAL LH,LL
      COMPLEX*16 YD(7),YR(3,7),P0(9),HHC,HLC,AP(2),AM(2),AI(3,2),FI,P,
     1AKI,ALP(7,2),RL,RH,BET(4),GAM(7,2),A(4),DP(4),FAC,FID(9)
      COMMON/BUGGER/M,IDEBUG,AK,AK2,AKI/PEES/P,DP/PEXCIT/P0,FID
     1/GQ16/W3(16),Y3(16)
C COMPUTE THE INTEGRALS AI USING 16-POINT GAUSSIAN QUADRATURE.
      P0(1)=(0.0D0,0.0D0)
      M=1
      LH=DREAL(HHC).EQ.0D0                                              JPB
      LL=DREAL(HLC).EQ.0D0                                              JPB
      IF(LH)GOTO 70
      AP(1)=0.5D0*(HLC+HHC)
      AM(1)=AP(1)-HHC
      AP(2)=0.5D0*HLC
      AM(2)=-AP(2)
      LMAX=2
      IF(LL)LMAX=1
      DO 30 L=1,LMAX
      DO 10 N=1,3
   10  AI(N,L)=(0.0D0,0.0D0)
      DO 20 I=1,16
       CALL PFUNCS(0,AM(L)*Y3(I)+AP(L))
       FI=0.0004D0*W3(I)
      DO 20 N=1,3
       FI=3.125D6*P*FI
   20  AI(N,L)=AI(N,L)+FI
      DO 30 N=1,3
       AI(N,L)=AM(L)*AKI*AI(N,L)
       IF(L.EQ.2)AI(N,2)=AI(N,1)+2.0D0*AI(N,2)
   30  CONTINUE
      IF(IDEBUG.EQ.2)WRITE(6,1000)AI
 1000 FORMAT('0AI =',6E15.7/5X,6E15.7 /' YCALC-1819')
C COMPUTE THE ARRAY ALP.
      DO 50 L=1,LMAX
       ALP(1,L)=(1.0D0,0.0D0)
      DO 40 N=2,7
   40  ALP(N,L)=ALP(N-1,L)*AI(1,L)/(N-1.0D0)
       ALP(4,L)=ALP(4,L)-0.5D0*AI(2,L)
       ALP(5,L)=ALP(5,L)-0.5D0*AI(2,L)*AI(1,L)
       ALP(6,L)=ALP(6,L)-0.5D0*AI(2,L)*ALP(3,L)+0.5D0*AI(3,L)
   50  ALP(7,L)=ALP(7,L)-AI(2,L)*(0.5D0*ALP(4,L)+0.125D0*AI(2,L))+
     1  0.5D0*AI(1,L)*AI(3,L)
      IF(IDEBUG.EQ.2)WRITE(6,2000)ALP
 2000 FORMAT('0ALP=',6E15.7/5X,8E15.7 /' YCALC-1831')
C COMPUTE THE ARRAY BET.
      CALL PFUNCS(0,HLC)
      RL=6.25D6*P
      CALL PFUNCS(0,HHC)
      RH=6.25D6*P
      BET(1)=(1.0D0,0.0D0)
      BET(2)=-0.25D0*(RL+RH)
      BET(3)=(5.0D0*(RL*RL+RH*RH)+2.0D0*RL*RH)/32.0D0
      BET(4)=-(RL*RL*(3.0D0*RL+RH)+RH*RH*(3.0D0*RH+RL))/25.6D0
      IF(IDEBUG.EQ.2)WRITE(6,3000)BET
 3000 FORMAT('0BET=',8E15.7 /' YCALC-1842')
C COMPUTE THE ARRAY GAM.
      DO 60 L=1,LMAX
      DO 60 N=1,7
       IMAX=(N-1)/2+1
       GAM(N,L)=(0.0D0,0.0D0)
      DO 60 I=1,IMAX
       IS=N-2*I+2
   60  GAM(N,L)=GAM(N,L)+ALP(IS,L)*BET(I)
      IF(IDEBUG.EQ.2)WRITE(6,4000)GAM
 4000 FORMAT('0GAM=',8E15.7/(5X,8E15.7) /' YCALC-1852')
C COMPUTE THE ARRAY A.
   70 CALL PFUNCS(4,(0.0D0,0.0D0))
      FAC=3.125D6
      DO 80 N=1,4
        FAC=1250.0D0*FAC/AKI
   80   A(N)=DP(N)*FAC
      A(4)=A(4)-2.5D0*A(1)*A(1)
      IF(IDEBUG.EQ.2)WRITE(6,5000)A
 5000 FORMAT('0A  =',8E15.7 /' YCALC-1861')
C COMPUTE THE ARRAYS YD AND YR.
      DO 90 N=1,7
       YD(N)=(0.0D0,0.0D0)
      DO 90 I=1,3
   90  YR(I,N)=(0.0D0,0.0D0)
      IF(LH)GOTO 120
      DO 100 N=1,7
       YD(N)=GAM(N,1)
  100  YR(1,N)=GAM(N,LMAX)
      DO 110 N=1,4
       YR(2,N)=(0.0D0,0.0D0)
      DO 110 M=1,N
        N1=N+1-M
  110   YR(2,N)=YR(2,N)+A(M)*YR(1,N1)
      YR(3,1)=YR(2,1)*A(1)
      GOTO 140
  120 YD(1)=(1.0D0,0.0D0)
      YR(1,1)=(1.0D0,0.0D0)
      DO 130 N=1,4
  130   YR(2,N)=A(N)
      YR(3,1)=A(1)*A(1)
  140 IF(IDEBUG.EQ.2)WRITE(6,6000)(YD(N),(YR(I,N),I=1,3),N=1,7)
 6000 FORMAT('0',14X,'YD(N)',27X,'YR(1,N)',26X,'YR(2,N)',26X,'YR(3,N)'/
     14(2X,'(',E14.7,',',E14.7,')') /' YCALC-1884')

      END SUBROUTINE YCALC


      SUBROUTINE FLATX3(DEL,PSI0,DMIN,DMAX,DSTEP,LOGLIN,HLC,HHC)
C FLATX3 COMPUTES THE FIELD STRENGTH-DISTANCE VARIATION FOR TERMINALS
C CLOSE TO THE SURFACE AT SHORT RANGES.A SERIES GENERALISATION OF THE
C SOMMERFELD FLAT EARTH THEORY IS USED.
      IMPLICIT REAL *8(A-H,O-Z)
      REAL*8 D(100),EDB(100),TL(100)
      COMPLEX *16 U,TAUD,TAUR,TAUP,HHC,HLC,PSI0,ER,FS,YR(3,7),JRP(4,7),
     1 FAC,S,TERMS,FD,FR,TERMD,TERMR,FACD,FACR,YD(7),JD(17),F,TERM,AKI
      COMMON/BUGGER/M,IDEBUG,AK,AK2,AKI/BROCK/HTU(20),HRU(20),FREQ,TLC,IPOLRN
C FIRST VALUE OF RANGE.
      NAF=0
      N=1
      D(1)=DMIN
C COMPUTE ARRAYS YD AND YR USING YCALC.
      CALL YCALC(HLC,HHC,YD,YR)
C COMPUTE ARRAYS JD AND JRP USING JCALC AND JRCALC.
   10 A=1000.D0*D(N)/(1.0D0+0.5D0*DEL)
      U=(0.5D0,-0.5D0)*DSQRT(A*AK)                                      JPB
      TAUD=-U*(HHC-HLC)/A
      TAUR=-U*(HHC+HLC)/A
      TAUP=TAUR-U*PSI0
      U=0.0004D0*U
      IF(IDEBUG.EQ.2)WRITE(6,1000)TAUD,TAUR,TAUP
 1000 FORMAT('0TAUD=(',E14.7,',',E14.7,')   TAUR=(',E14.7,',',E14.7
     1,')   TAUP=(',E14.7,',',E14.7,')' /' FLATX3-1911')
      CALL JRCALC(TAUP,TAUR,JRP)
      CALL JCALC(7,TAUD,JD)
C COMPUTE THE SURFACE WAVE FROM A SERIES IN POWERS OF U.
      ER=(1.0D0,0.0D0)
      IF(DREAL(HHC).GT.0.0D0)ER=CDEXP(TAUR*TAUR)                        JPB
      FS=ER*YR(1,1)*JRP(2,7)
      FAC=ER
      IF(IDEBUG.EQ.2)WRITE(6,2000)FS,FS
 2000 FORMAT(15X,'FS',34X,'TERMS'/1X,2('(',E14.7,',',E14.7,')',6X)
     1  /' FLATX3-1921')
        DO 30 I=1,6
        FAC=FAC*U
        S=(0.0D0,0.0D0)
        LMAX=1+I/3
        SN=-1.0D0
        DO 20 L=1,LMAX
          SN=-SN
          ML=I-3*L+4
          ML1=I-L+1
   20     S=S+SN*YR(L,ML)*JRP(L+1,ML1)
        TERMS=FAC*S
        FS=FS+TERMS
        IF(IDEBUG.EQ.2)WRITE(6,3000)FS,TERMS
 3000 FORMAT(1X,2('(',E14.7,',',E14.7,')',6X) ' FLATX3-1936')
   30   CONTINUE
C COMPUTE THE SPACE WAVE FROM SERIES IN POWERS OF U.
      FD=(0.0D0,0.0D0)
      FR=(0.0D0,0.0D0)
      TERMD=(0.0D0,0.0D0)
      TERMR=(0.0D0,0.0D0)
      IF(DREAL(HLC).EQ.0.0D0)GOTO 50                                    JPB
      FACD=0.5D0*CDEXP(TAUD*TAUD)
      FACR=-0.5D0*ER
      IF(IDEBUG.EQ.2)WRITE(6,4000)
 4000 FORMAT(17X,'FD',30X,'TERMD',29X,'FR',30X,'TERMR' ' FLATX3-1947')
        DO 40 I=1,7
        TERMD=FACD*YD(I)*JD(I)
        TERMR=FACR*YR(1,I)*JRP(1,I)
        FD=FD+TERMD
        FR=FR+TERMR
        IF(IDEBUG.EQ.2)WRITE(6,5000)FD,TERMD,FR,TERMR
 5000 FORMAT(1X,4(2X,'(',E14.7,',',E14.7,')') /' FLATX3-1954')
        FACD=FACD*U
   40   FACR=FACR*U
C COMPUTE THE FIELD STRENGTH IN DB RELATIVE TO 1 MICROVOLT/M.
C THE REFERENCE DIPOLE HAS A FIELD STRENGTH OF 150.0 MICROVOLT/METRE AT
C A DISTANCE OF 1 KM.
   50 F=FS+FD+FR
      TERM=TERMS+TERMD+TERMR
      EDB(N)=10.0D0*DLOG10(8.877D10*ABS2(F)/(D(N)*D(N)))
      TL(N)=TLC-EDB(N)
      IF(IDEBUG.EQ.2)WRITE(6,6000)F,TERM,U,D(N),EDB(N)
 6000 FORMAT('0F=(',E12.5,',',E12.5,') TERM=(',E12.5,',',E12.5
     1,') U=(',E12.5,',',E12.5,') D=',E14.7,' EDB=',E14.7
     2  /' FLATX3-1965')
C CHECK FOR CONVERGENCE.
      IF(NAF.EQ.1)GOTO 80
      ERR=ABS2(TERM/F)
      IF(ERR.LT.0.0025D0)GOTO 60
      D(N)=D(N)*(0.0025D0/ERR)**(1.0D0/6.0D0)
      NAF=1
      GOTO 10
   60 IF(N.EQ.100)GOTO 80
C COMPUTE THE NEXT RANGE.
      N=N+1
      IF(LOGLIN.EQ.0)D(N)=D(N-1)+DSTEP
      IF(LOGLIN.EQ.1)D(N)=D(N-1)*DSTEP
C**********
      IF(D(N).GE.DMAX)THEN
      D(N)=DMAX
      NAF=1
      END IF
C**********
      IF(D(N).LE.DMAX)GOTO 10
   70 N=N-1
C PRINT MAIN RESULTS.
   80 HH=DREAL(HHC)                                                     JPB
      HL=DREAL(HLC)                                                     JPB
      IF(IDEBUG.GE.1)WRITE(6,7000)HH,HL,(D(N1),EDB(N1),N1=1,N)
 7000 FORMAT(//' NEAR ZONE USING FLATX3   TERMINAL HEIGHTS=',2E15.7,' M'
     1/6X,'RANGE',14X,'FIELD STRENGTH'/8X,'KM',15X,
     2'DB ABOVE 1 MICROVOLT/M'/(1X,E14.7,E24.7) 'FLATX3-1992')
      IF(IDEBUG.EQ.0)WRITE(6,8000)(D(N1),EDB(N1),TL(N1),N1=1,N)
C********
 8000 FORMAT(1H ,22X,F7.2,7X,F7.2,14X,F7.2 )

      END SUBROUTINE FLATX3


      FUNCTION PINTAB(J,HA,HB)
C PINTAB COMPUTES THE PHASE INTEGRAL (J=1),ITS FIRST (J=2) OR SECOND
C (J=3) DERIVATIVE WITH RESPECT TO P0(M) FROM HA TO HB.16-POINT
C GAUSSIAN QUADRATURE IS USED.
C
C PINTAB(1,HA,HB)=I*K*THE INTEGRAL CSQRT(P(H,P0)) FROM HA TO HB.
C PINTAB(2,HA,HB)=FIRST DERIVATIVE OF THE ABOVE WRT P0(M) AND ECT.
C
C PINTAB IS CALLED BY COMINT AND IT CALLS PFUNCS.
C
      IMPLICIT REAL *8(A-H,O-Z)
      REAL *8 A(3)/1.0D0,0.5D0,-0.25D0/
      COMPLEX *16 PINTAB,HA,HB,FP,FM,FAC,P,AKI,DP(4),D1P,D2P
      COMMON/BUGGER/M,IDEBUG,AK,AK2,AKI/GQ16/W3(16),Y3(16)/PEES/P,DP
C
C Y3 AND W3 ARE THE GAUSSIAN ABCISSAS AND THE WEIGHTS
C
      FP=0.5D0*(HB+HA)
      FM=FP-HA
      PINTAB=(0.0D0,0.0D0)
        DO 10 I=1,16
C
        CALL PFUNCS(0,FM*Y3(I)+FP)
C
        FAC=W3(I)*CDSQRT((0.0D0,-0.5D0)*P)
        IF(J.GE.2)FAC=FAC/P
        IF(J.EQ.3)FAC=FAC/P
   10   PINTAB=PINTAB+FAC
      PINTAB=A(J)*(1.0D0,1.0D0)*AKI*FM*PINTAB
C     IF(IDEBUG.EQ.2)PRINT*,'PINTAB=',PINTAB ,'PINTAB-2030'

      END FUNCTION PINTAB


      FUNCTION COMINT(J,M,HLC,HHC,H1)
C COMINT COMPUTES COMBINATIONS OF PHASE INTEGRALS USED IN RAY.
C
C COMINT IS CALLED BY RAY.IT IN TURN CALLS PINT AND PINTAB.
C
      IMPLICIT REAL *8(A-H,O-Z)
      LOGICAL A,B
      COMPLEX *16 COMINT,PINT,HLC,HHC,PINTAB,FAC,H1(9),CC1,CC2,AKI      JPB
      COMMON/BUGGER/N,IDEBUG,AK,AK2,AKI
      GOTO(10,30,40),M
      IF(IDEBUG.GE.1)WRITE(6,1000)M
 1000 FORMAT(' M=',I1,' IN COMINT' ' COMINT-2043')
      STOP
   10 IF(DREAL(HLC-H1(M)).LT.DMAX1(10.0D0,DREAL(HHC-HLC)))GOTO20        JPB
C
C**IF J=1 THEN COMINT INTEGRATES I*K*(P(PO,H))**0.5 FROM HHC TO HLC.
C J=2 ;IT'S FIRST DERIVATIVE WITH RESPECTIVE TO PO FROM HHC TO HLC.
C J=3 ;::::SECOND:::::::::::::::::::::::::::::::::::::::::::::::::.
C
      COMINT=PINTAB(J,HHC,HLC)
      IF(IDEBUG.EQ.2)WRITE(6,2000)J,COMINT
 2000 FORMAT(' COMINT(',I1,')=(',E14.7,',',E14.7,')' ' COMINT-2053')
      RETURN
   20 IF(DREAL(HLC-H1(M)).LT.0.0D0)GO TO 30                             JPB
      COMINT=PINT(J,HLC,M,H1)-PINT(J,HHC,M,H1)
C
C**PINT(1,HLC) INTEGRATES I*K*CSQRT(P(PO,H)) FROM THE TURNINIG POINT H1
C TO HLC.J=2;IT'S FIRST DERIVATIVE.J=3 IT'S SECOND DERIVATIVE.
C
      RETURN
   30 COMINT=-PINT(J,HLC,M,H1)-PINT(J,HHC,M,H1)
      RETURN
   40 A=DREAL(-H1(M)).LT.DMAX1(10.0D0,DREAL(HLC))                       JPB
      B=DREAL(-H1(M)).LT.DMAX1(10.0D0,DREAL(HHC))                       JPB
      IF(A)COMINT=2.0D0*PINT(J,(0.0D0,0.0D0),M,H1)-
     1 PINT(J,HLC,M,H1)-PINT(J,HHC,M,H1)
      IF(.NOT.A.AND.B)COMINT=PINT(J,(0.0D0,0.0D0),M,H1)-
     1 PINT(J,HHC,M,H1)+PINTAB(J,HLC,(0.0D0,0.0D0))
      IF(.NOT.B)COMINT=2.0D0*PINTAB(J,HLC,(0.0D0,0.0D0))+
     1 PINTAB(J,HHC,HLC)

      END FUNCTION COMINT


      SUBROUTINE RAY(*,DEL,SC,D1P0,M,P0,HLC,HHC,D,DC,DH,DL,H1,F,
     1 FDD,G)
C RAY COMPUTES COMPONENTS OF THE DIRECT RAY BEFORE (M=1) OR AFTER
C (M=2) IT HAS TURNED OR THE REFLECTED RAY (M=3).THESE COMPONENTS
C ARE USED IN STATIONARY PHASE INTEGRATIONS.
      IMPLICIT REAL *8(A-H,O-Z)
      COMPLEX *16 P0(9),HLC,HHC,P,AKI,FAC,DP0,F(9),FDD(9),COMINT,G(9),
     1 H1(9),YY2,YY3,DP(4)
      COMMON/BUGGER/N,IDEBUG,AK,AK2,AKI /PEES/P,DP
      FUNC(X)=B*X-DH*DH*D-X*(D-X)*(D-2.D0*X)                            JPB
C     CALL UNFLOW ***Marconi mainframe routine***
      A=250.0D0*D1P0/(1.0D0+0.5D0*DEL)
C COMPUTE A STARTING VALUE FOR THE SADDLE POINT P0(M) WHEN D IS
C CLOSER TO THE HORIZON THAN TO DC.
      IF(M.EQ.3)GOTO 10
      IF(D-DC.LT.DH+DL-D)GOTO 90
      P0(2)=(D-DH-DL)*(D-DH+DL)*(D+DH-DL)*(D+DH+DL)*A*A/(D*D)
      GOTO 100
   10 B=DH*DH+DL*DL
      IF(DH.NE.DL)GOTO 20
      DHIGH=0.5D0*D
      GOTO 80
   20 D0=0.5D0*D
      D1=D*DH*DH/B
      F0=FUNC(D0)
      F1=FUNC(D1)
      DO 70 ITER=1,20
        DHIGH=D1-(D1-D0)*F1/(F1-F0)
        D3=1.D-4*DHIGH                                                  JPB
        D4=DABS(DHIGH-D1)                                               JPB
        D5=DABS(DHIGH-D0)                                               JPB
        IF(D4.LT.D3.OR.D5.LT.D3)GOTO 80
        F2=FUNC(DHIGH)
        IF(D5.GT.10.0D0*D4)GOTO 30
        IF(D4.GT.10.0D0*D5)GOTO 40
        GOTO 50
   30   D3=0.5D0*(DHIGH+D0)
        F3=FUNC(D3)
        IF(DSIGN(1.0D0,F0).NE.DSIGN(1.0D0,F3))GOTO 50                   JPB
        D0=D3
        F0=F3
        GOTO 50
   40   D3=0.5D0*(DHIGH+D1)
        F3=FUNC(D3)
        IF(DSIGN(1.0D0,F1).NE.DSIGN(1.0D0,F3))GOTO 50                   JPB
        D1=D3
        F1=F3
        GOTO 50
   50   IF(DSIGN(1.0D0,F2).EQ.DSIGN(1.0D0,F1))GOTO 60                   JPB
        F0=F2
        D0=DHIGH
        GOTO 70
   60   F1=F2
        D1=DHIGH
   70   CONTINUE
      IF(IDEBUG.GE.1)WRITE(6,1000)
 1000 FORMAT(' DHIGH HAS NOT CONVERGED IN RAY' ' RAY-2130')
      STOP
   80 P0(3)=(DH*DH/DHIGH-DHIGH)*A
      P0(3)=P0(3)*P0(3)
      GOTO 100
C COMPUTE A STARTING VALUE FOR THE SADDLE POINT P0(M) WHEN D IS
C CLOSER TO DC THAN THE HORIZON.
   90 PL=(DC*DC/D-D)*A
      PL=PL*PL
      P0(M)=(0.0D0,0.0D0)
      CALL PFUNCS(0,HLC)
      P0(M)=PL-P
      IF(IDEBUG.EQ.2)WRITE(6,2000)D,M,P0(M)
 2000 FORMAT(' D=',E14.7,'   P0(',I1,')=(',E14.7,',',E14.7,')'
     1 ' RAY-2143')
C COMPUTE THE SADDLE POINT P0(M) BY NEWTONS METHOD
  100 FAC=500.0D0*D*AKI/(1.0D0+DEL)
      CALL TPOINT(DEL,SC,M,P0,H1)
      DO 110 ITER=1,9
       DP0=(FAC+COMINT(2,M,HLC,HHC,H1))/COMINT(3,M,HLC,HHC,H1)
       P0(M)=P0(M)-DP0
       CALL TPOINT(DEL,SC,M,P0,H1)
       IF(IDEBUG.EQ.2)WRITE(6,3000)ITER,DP0,M,P0(M),H1(M)
 3000 FORMAT(' ITER=',I1,'   DP0=(',E14.7,',',E14.7,')   P0(',I1,
     1')=(',E14.7,',',E14.7,')   H1=(',E14.7,',',E14.7,')' /' RAY-2153')
        EPS=ABS2(DP0/P0(M))
        IF(EPS.LT.1.0D-8.OR.ABS2(DP0).LT.1.0D-18)GO TO 120
  110   CONTINUE
      IF(IDEBUG.GE.0)WRITE(6,4000)M
 4000 FORMAT(' P0(',I1,') HAS NOT CONVERGED IN RAY')
      IF(EPS.LT.1.E-6)GO TO 120
      RETURN 1
C COMPUTE THE QUANTITUES F(M),FDD(M) AND G(M) REQUIRED FOR
C STATIONARY PHASE INTEGRATION.
  120 F(M)=FAC*P0(M)+COMINT(1,M,HLC,HHC,H1)
      FDD(M)=COMINT(3,M,HLC,HHC,H1)
      CALL PFUNCS(0,HLC)
      FAC=P
      CALL PFUNCS(0,HHC)
      G(M)=1.0D0/CDSQRT(CDSQRT(FAC*P))
      IF(IDEBUG.EQ.2)WRITE(6,5000)M,P0(M),H1(M),F(M),FDD(M),G(M)
 5000 FORMAT(' M=',I1,' P0=(',E9.2,',',E9.2,') H1=(',E9.2,',',E9.2,
     1') F=(',E9.2,',',E9.2,') FDD=(',E9.2,',',E9.2,') G=(',E9.2,',',
     2E9.2,')' /' RAY-2171')

      END SUBROUTINE RAY


      SUBROUTINE GEOMOP(DEL,SC,D1P0,PSI0,DMIN,DMAX,DSTEP,
     1 LOGLIN,JR,JT,LRMIN,LTMIN,HR,HT,DM)
C GEOMOP COMPUTES THE FIELD USING GEOMETRICAL OPTICS.
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMPLEX *16 FAC,AKI,P0(9),HLC,HHC,P,H1(9),PINT,EDEXP,G(9),FDD(9) ,
     1F(9),FAC1,R,EREXP,PSI0,FID(9),DP(4)
      REAL *8 HR(20),HT(20),DM(20,20)
      COMMON/BUGGER/M,IDEBUG,AK,AK2,AKI/BROCK/HTU(20),HRU(20),FREQ,
     1TLC,IPOLRN /PEES/P,DP/PEXCIT/P0,FID
      CHARACTER *4 LITF,LITG
      LITF='(F)'
      LITG='(G)'
      HN=120.0D0*AK**(-2.0D0/3.0D0)
      FAC=2.0D-3*(1.0D0+0.5D0*DEL)/AKI
      LR=LRMIN
      LT=LTMIN
      TLC=BTLC(HTU(LT),HRU(LR),1D6*FREQ,IPOLRN)                         JPB
      HLC=CMPLX(DMIN1(HR(LR),HT(LT)),0.0D0)
      HHC=CMPLX(DMAX1(HR(LR),HT(LT)),0.0D0)
C IF HR(LR) AND HT(LT) ARE SMALL USE THE EXTENDED FLAT EARTH METHOD
C IN FLATX3.
      IF(HR(LR).GT.HN.OR.HT(LT).GT.HN) GOTO10
      IF(IDEBUG.EQ.0)WRITE(6,2000)FREQ,HTU(LT),HRU(LR),LITF
C************
      DMAXI=DM(LR,LT)
      IF(IDEBUG.EQ.0.AND.DMIN.EQ.DM(LR,LT))RETURN
C***************
      CALL FLATX3(DEL,PSI0,DMIN,DMAXI,DSTEP,LOGLIN,HLC,HHC)
      GOTO 50
C---------------------------------------------------------------------- MARCONI
C WHEN HT=HR THEN                                                       MARCONI
C FUNCTION PINT IS 0.0 WHEN (HX-HT) IS LESS THAN 10-3*HT, WHERE HX IS   MARCONI
C THE LARGER OF THE WEIGHTS OF THE TRANSMITTER OR RECEIVER AND  HT IS   MARCONI
C THE TURNING POINT.WHEN PINT IS 0.0 THIS MAKES COMINT(2,...) AND       MARCONI
C COMINT(3,...) EQUAL TO (0.0,0.0). THIS MAKES DP0 ZERO IN RAY AND THE  MARCONI
C PROGRAM FAILS. THE REASON WHY THE PROGRAM FAILS IS BECAUSE DMIN IS    MARCONI
C TOO SMALL AND WHICH RESULT IN THE DISTANCE BETWEEN HX AND HT IS TOO   MARCONI
C SMALL. TO REMEDY THIS, INTRODUCE THE NEW MINIMUM DISTANCE DMINIM.     MARCONI
C    DMIN=1.1*(4.0*2*RE*10-3*HT)**1/2. WHERE RE=EFFECTIVE EARTH RADIUS  MARCONI
C    1.2 IS A SMALL FACTOR BECAUSE THE ABOVE EXPRESSION IS NOT EXACT.   MARCONI
   10 HMAX=DMAX1(HR(LR),HT(LT))                                         MARCONI
      DMINIM=1.2*DSQRT(8.0*4.0/3.0*6.37D6*1.0D-3*HMAX)*1.0D-3           JPB-MAR
C     PRINT*,'HMAX=',HMAX,'DMINIM=',DMINIM,'DMIN=',DMIN                 MARCONI
      DMIN=DMAX1(DMIN,DMINIM)                                           MARCONI
C---------------------------------------------------------------------- MARCONI
C COMPUTE DC,THE DISTANCE AT WHICH THE DIRECT RAY FROM HEIGHT HHC
C TURNS AT HEIGHT HLC.DISTANCES ARE IN KILOMETRES.
      M=1                                                               MARCONI
      P0(1)=(0.0D0,0.0D0)
      CALL PFUNCS(0,HLC)
      P0(1)=-P
      H1(1)=HLC
      DC=DREAL(FAC*PINT(2,HHC,M,H1))                                    JPB
C COMPUTE DH AND DL,THE DISTANCES AT WHICH THE DIRECT RAYS FROM
C HEIGHTS HHC AND HLC TURN AT THE SURFACE.THEIR SUM,DZ,IS THE
C HORIZON DISTANCE.
      P0(1)=(0.0D0,0.0D0)
      H1(1)=(0.0D0,0.0D0)
      DH=DREAL(FAC*PINT(2,HHC,M,H1))                                    JPB
      DL=DREAL(FAC*PINT(2,HLC,M,H1))                                    JPB
      DZ=DL+DH
      IF(IDEBUG.GE.1)WRITE(6,1000)HT(LT),HR(LR),DC,DH,DL,DZ
 1000 FORMAT(////' GEOMETRICAL OPTICS FIELD FROM GEOMOP'/
     1'  HT=',E14.7,'M  HR=',E14.7,'M  DC=',
     2E14.7,'KM  DH=',E14.7,'KM  DL=',E14.7,'KM  DZ=',E14.7,'KM'
     3//7X,'D',15X,'E',14X,'EFS',14X,'ED',14X,'ER',13X,'EMAX',
     412X,'EMIN',11X,'PHDIFF'/7X,'KM',6(14X,'DB'),14X,'2*PI'
     5 /' GEOMOP-2238')
      IF(IDEBUG.EQ.0)WRITE(6,2000)FREQ,HTU(LT),HRU(LR),LITG
 2000 FORMAT(//21X,'FREQUENCY =',F9.3,' MHZ'//21X,'TRANSMITTER HEIGHT ='
     1,F8.1,2X,'METRES'/21X,'RECIEVER HEIGHT    =',F8.1,2X,'METRES'//21X
     2,'DISTANCE      FIELD STRENGTH     BASIC TRANSMISSION LOSS'/21X,'
     3  KM            DB(UV/M)               DB',11X,A4)
C COMPUTE THE FIRST RANGE D.
      N=1
      D=DMIN
      IF(IDEBUG.GE.1)PRINT*,'DMIN',DMIN ,'DZ',DZ,'N',N,'LR',LR, 'LT',LT,
     1 'DM',DM(LR,LT) ,'GEOMOP-2253'
C***************************
      IF(IDEBUG.EQ.0.AND.DMIN.EQ.DM(LR,LT))RETURN
C***************************
      IFIN=0
C IF D IS GREATER THAN THE HORIZON DISTANCE DZ OR 100 EVALUATIONS
C HAVE BEEN MADE,PROCEED TO THE NEXT HEIGHT.
   20 IF((D.GE.DZ.AND.DM(LR,LT).GE.DZ).OR.N.GT.100)GOTO50
C IF D IS GREATER THAN THE MAXIMUM RANGE DM(LR,LT) OR .75*DZ COMPUTE
C AT THIS RANGE AND THEN PROCEED TO THE NEXT HEIGHT.
      IF(IFIN.EQ.1)GOTO 50
      IF(D.LT.DM(LR,LT).AND.DM(LR,LT).LT.DZ)GOTO 30
C******************
      IF(D.GE.DM(LR,LT).AND.DM(LR,LT).LT.DZ)THEN
      D=DM(LR,LT)
      IFIN=1
      GOTO 30
      END IF
C*******************
      IF(D.LT.DM(LR,LT).OR.D.LT.0.75D0*DZ)GOTO30
      D=DMAX1(DM(LR,LT),0.75D0*DZ)
      IFIN=1
C COMPUTE THE DIRECT WAVE.
   30 M=1
      IF(D.GT.DC)M=2
      CALL RAY (*100,DEL,SC,D1P0,M,P0,HLC,HHC,D,DC,DH,DL,H1,F,FDD,G)
      EDEXP=CMPLX(0.D0,(2.0D0-M)*1.570796)+0.5D0*CDLOG(5.625D12*AK*G(M)
     1 *G(M)/(D*FDD(M)))+F(M)
C COMPUTE THE REFLECTED WAVE.
      M=3
      CALL RAY(*100,DEL,SC,D1P0,M,P0,HLC,HHC,D,DC,DH,DL,H1,F,FDD,G)
      FAC1=CDSQRT(P0(3))
      R=CDLOG(G(3)*(PSI0-FAC1)/(PSI0+FAC1))
      EREXP=(0.0D0,4.712389D0)+0.5D0*CDLOG(5.625D12*AK/(D*FDD(3)))+F(3)+
     1 R
C COMPUTE THE FIELD STRENGTH E,FREE SPACE FIELD EFS,DIRECT WAVE ED,
C REFLECTED WAVE ER,ENVELOPES OF THE INTERFERENCE PATTERN EMAX AND
C EMIN ALL IN DECIBALS RELATIVE TO 1 MICROVOLT/M.COMPUTE THE PHASE
C DIFFERENCE PHDIFF BETWEEN THE REFLECTED AND DIRECT WAVES IN UNITS
C OF 2*PI=6.283185.
C THE REFERENCE DIPOLE HAS A FIELD STRENGTH OF 150.0 MICROVOLT/M AT A
C DISTANCE OF 1 KM IN FREE SPACE.
      ED=8.686D0*DREAL(EDEXP)                                           JPB
      E=ED+10.0D0*DLOG10(ABS2(1.0D0+CDEXP(EREXP-EDEXP)))                JPB
      EFS=20.0D0*DLOG10(1.50D5/D)
      ER=8.686*DREAL(EREXP)                                             JPB
      A=DEXP(DREAL(EREXP-EDEXP))                                        JPB
      EMAX=ED+20.0D0*DLOG10(1.0D0+A)
      EMIN=ED+20.0D0*DLOG10(DABS(1.0D0-A))                              JPB
      PHDIFF=DIMAG(EREXP-EDEXP)/6.283185
      IF(IDEBUG.GE.1)WRITE(6,3000)D,E,EFS,ED,ER,EMAX,EMIN,PHDIFF
 3000 FORMAT(E15.7,7E16.7, ' GEOMOP-2304')
      TL=TLC-E
      IF(IDEBUG.EQ.0)WRITE(6,4000)D,E,TL
C*********
 4000 FORMAT(1H ,22X,F7.2,7X,F7.2,14X,F7.2)
C COMPUTE THE NEXT RANGE D.
  100 IF(LOGLIN.EQ.0)D=D+DSTEP
      IF(LOGLIN.EQ.1)D=D*DSTEP
      N=N+1
      GOTO 20


   50 END SUBROUTINE GEOMOP
C***********************************************************************
C Free-format Fortran-77 input routines.                               *
C Copyright (C) GEC plc 1985                                           *
C***********************************************************************
C High-level input routines - read words, numbers or strings.          *
C A number is anything delimited by blanks which can be read by Fortran*
C F-format. A word is anything delimited by blanks which doesn't begin *
C with +-.0123456789 . A string is either the rest of the current line *
C or a sequence of characters delimited by a non-blank, all on one line*
C Strings may be in lower-case; words are translated to uppercase      *
C Multiple entry points and SAVEd variables are used to provide        *
C state memory without the use of COMMON                               *
C***********************************************************************
      SUBROUTINE WORDN(WN, IERR)

      PARAMETER (LINE=80)
      DOUBLEPRECISION    VALUE, D
      LOGICAL            REPEAT, ENDF, ENDL
      CHARACTER * (LINE) WORK, W, ST
      CHARACTER * (*)    WN
      CHARACTER * 1      CH, DELIM
      CHARACTER * 4      W4
      CHARACTER * 8      W8
      SAVE               W, ST, IWERR, INERR, IWL, VALUE, REPEAT        JPB
      DATA W/' '/, ST/' '/
      DATA IWERR/0/, INERR/0/, IWL/0/, VALUE/0.0D0/, REPEAT/.FALSE./
C***********************************************************************
C                                                                      *
C Words:                                                               *
C                                                                      *
C***********************************************************************
C                                                                      *
C WORDN reads a word of any length; WORD4/8 are for compatibility with *
C IBM Fortran-IV programs which can't pass any indication of           *
C the size of a character variable.                                    *
C                                                                      *
C***********************************************************************
      IENTRY = 1
      GOTO 10
      ENTRY WORD4(W4, IERR)
      ENTRY WORD(W4, IERR)
      IENTRY = 2
      GOTO 10
      ENTRY WORD8(W8, IERR)
      IENTRY = 3
C Repeat requested?                                                    *
   10 IF (REPEAT) GOTO 40
      IWERR = 0
      W = ' '
C Skip leading spaces                                                  *
   20    CALL RDCHR(CH, ENDF, ENDL, .TRUE.)
C Premature EOF - return IERR = 2                                      *
         IF (ENDF) THEN
            IWERR = 2
            GOTO 40
         ENDIF
      IF (CH .EQ. ' ') GOTO 20
C If object starts like a number, unread it and return IERR=1          *
      IF (INDEX('0123456789.+-',CH).NE.0) THEN
         CALL BACKSP
         IWERR = 1
         GOTO 40
      ENDIF
C Accumulate characters in W until space or EOF found                  *
      IPT = 0
   30    IPT = IPT + 1
         W(IPT:IPT) = CH
         CALL RDCHR(CH, ENDF, ENDL, .TRUE.)
      IF ( .NOT.ENDF .AND. CH.NE.' ') GOTO 30
C Copy into appropriate return parameter                               *
   40 IERR = IWERR
      IF (IENTRY.EQ.1) WN = W
      IF (IENTRY.EQ.2) W4 = W
      IF (IENTRY.EQ.3) W8 = W
      REPEAT = .FALSE.
      RETURN
C***********************************************************************
C Set flag to cause next call of a read routine to return same value as*
C previous call. For this purpose, all word routines, the string       *
C routine, and all number routines, are each treated as one entry      *
C***********************************************************************
      ENTRY UNREAD
      REPEAT = .TRUE.
      RETURN
C***********************************************************************
C                                                                      *
C Numbers:                                                             *
C                                                                      *
C***********************************************************************
      ENTRY RDINT(I, IERR)
      IENTRY = 1
      GOTO 50
      ENTRY READSP(S, IERR)
      IENTRY = 2
      GOTO 50
      ENTRY READDP(D, IERR)
      ENTRY RDREAL(D, IERR)
      IENTRY = 3
C***********************************************************************
C RDREAL is present for compatibility only - note that it reads        *
C DOUBLE PRECISION, not REAL]                                          *
C***********************************************************************
C Repeat requested?                                                    *
   50 IF (REPEAT) GOTO 90
      VALUE = 0.0D0
      INERR = 0
      WORK = ' '
C Skip leading spaces                                                  *
   60 CALL RDCHR(CH, ENDF, ENDL, .TRUE.)
C Premature EOF is treated as a 'word' ]                               *
      IF (ENDF) THEN
         INERR = 1
         GOTO 90
      ENDIF
      IF (CH.EQ.' ') GOTO 60
C***********************************************************************
C IF IT DOESN'T BEGIN 0123456789.+- THEN IT ISN'T A NUMBER - RETURN    *
C IERR=1 AND BACKSPACE                                                 *
C***********************************************************************
      IF (INDEX('0123456789.+-',CH).EQ.0) THEN
         INERR = 1
         CALL BACKSP
         GOTO 90
      ENDIF
C Accumulate characters until space or EOF                             *
      IPT = 0
   70    IPT = IPT + 1
         WORK(IPT:IPT) = CH
         CALL RDCHR(CH, ENDF, ENDL, .TRUE.)
      IF (CH.NE.' '.AND..NOT.ENDF) GOTO 70
C Attempt to do internal read as a number, interpreting blanks as nulls*
      READ(WORK, '(BN,F80.0)', ERR = 80) VALUE
      GOTO 90
C 'I/O error' must mean it wasn't a number - set IERR to 2             *
   80 VALUE = 0.0D0
      INERR = 2
C Copy into variable of appropriate type                               *
   90 IERR = INERR
      IF (IENTRY.EQ.1) THEN
         WRITE (WORK,'(F80.0)') VALUE
         READ(WORK,'(I79)',ERR=80) I
      ENDIF
      IF (IENTRY.EQ.2) S = VALUE
      IF (IENTRY.EQ.3) D = VALUE
      REPEAT = .FALSE.
      RETURN
C***********************************************************************
C String: type depends on IOPT.                                        *
C IOPT=1 - rest of line as is                                          *
C IOPT=2 - rest of line, stripped of leading & trailing spaces         *
C IOPT=3 - delimited by nonblanks (or end of line)                     *
C Length of character string returned in ILEN                          *
C***********************************************************************
      ENTRY RDSTRG(WN, IOPT, ILEN)
C Replay requested?                                                    *
      IF (REPEAT) GOTO 140
      IWL = 0
      ST = ' '
C Skip leading spaces if necessary                                     *
      IF (IOPT.EQ.2 .OR. IOPT.EQ.3) THEN
  100       CALL RDCHR(CH, ENDF, ENDL, .FALSE.)
            IF (ENDL) GOTO 140
         IF (CH.EQ.' ') GOTO 100
      ENDIF
C ACCUMULATE CHARACTERS UNTIL EOL                                      *
      IF (IOPT.EQ.1 .OR. IOPT.EQ.2) THEN
  110       IWL = IWL+1
            ST(IWL:IWL) = CH
            CALL RDCHR(CH, ENDF, ENDL, .FALSE.)
         IF (.NOT.ENDL) GOTO 110
      ENDIF
C Strip trailing spaces                                                *
  120 IF (IOPT.EQ.2 .AND. ST(IWL:IWL).EQ.' ') THEN

         IWL = IWL - 1
         GOTO 120
      ENDIF
C Read delimited string                                                *
      IF (IOPT.EQ.3) THEN
         CALL RDCHR(DELIM, ENDF, ENDL, .FALSE.)
         IF (ENDL) GOTO 140
  130       CALL RDCHR(CH, ENDF, ENDL, .FALSE.)
            IF (ENDL) GOTO 140
C Treat 2 consecutive delimiters as ordinary character                 *
            IF (CH.EQ.DELIM) THEN
               CALL RDCHR(CH, ENDF, ENDL, .FALSE.)
               IF (ENDL) GOTO 140
               IF (CH.NE.DELIM) THEN
                  CALL BACKSP
                  GOTO 140
               ENDIF
            ENDIF
            IWL = IWL + 1
            ST(IWL:IWL) = CH
         GOTO 130
      ENDIF
C Copy into output parameter and return                                *
  140 ILEN = IWL
      WN = ST
      REPEAT = .FALSE.

      END SUBROUTINE WORDN
C***********************************************************************
C Low-level free-format input routines.                                *
C These manage a 1-line buffer of length LINE and extract data from it *
C character by character. Comments are introduced by / or // and extend*
C to end of line. Comments starting // are verified.                   *
C End-of-line is treated as a space, but its presence can be tested.   *
C Again multiple entries and SAVE are used to obviate COMMON           *
C***********************************************************************
      SUBROUTINE RDCHAR(ICH, ENDF)
      PARAMETER (LINE = 80)
      LOGICAL ENDF, ENDL, E
      LOGICAL EOFL, EOL, VER, INTERP
      CHARACTER * (LINE) TEXT
      CHARACTER * (LINE+2) IFLAG
      CHARACTER * 1 C, CH
      CHARACTER * 26 UPPER, LOWER
      PARAMETER (LOWER = 'abcdefghijklmnopqrstuvwxyz')
      SAVE TEXT, IPOINT, IUNITI, IUNITO, EOFL, EOL, VER                 JPB
      DATA UPPER /'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
C  UPPER must be variable because substring of constant is not allowed *
      DATA IPOINT/0/, EOFL/.FALSE./, EOL/.TRUE./, VER/.FALSE./
      DATA IUNITI/5/, IUNITO/6/
      DATA TEXT/' '/
C***********************************************************************
C Entry RDCHAR reads a character in uppercase and returns its ordinal  *
C as given by the ICHAR function - this uses the implementation's own  *
C character ordering.                                                  *
C***********************************************************************
      IENTRY = 1
      GOTO 10
C***********************************************************************
C Entry RDCHR reads the character in either upper or mixed case and    *
C returns the character itself as a CHARACTER*1 variable               *
C***********************************************************************
      ENTRY RDCHR(CH, ENDF, ENDL, INTERP)
      IENTRY = 2
C At end of file return CHAR(0)                                        *
   10 IF (EOFL) THEN
         C = CHAR(0)
         GOTO 30
      ENDIF
C If buffer exhausted return space and set EOL                         *
      IF (IPOINT.GE.LINE) THEN
         C = ' '
         EOL = .TRUE.
         IPOINT = 0
         GOTO 30
      ENDIF
C If EOL already set, attempt to read a new line                       *
      IF (EOL) THEN
         READ (IUNITI, '(A)', END=20) TEXT
         EOL = .FALSE.
C Verify the line                                                      *
         IF (VER) WRITE (IUNITO, '('' +++ Input: '',A)') TEXT
      ENDIF
C Extract the next character from the buffer                           *
      IPOINT = IPOINT + 1
      C = TEXT(IPOINT:IPOINT)
C Interpret if necessary                                               *
      IF (IENTRY.EQ.1 .OR. INTERP) THEN
C Uppercase if necessary                                               *
         I = INDEX(LOWER, C)
         IF (I.NE.0) C = UPPER(I:I)
C Comments are treated as end of line - set EOL                        *
         IF (C .EQ. '/') THEN
            C = ' '
            EOL = .TRUE.
            IPOINT = 0
C Verify // comments                                                   *
            IF (TEXT(IPOINT:IPOINT+1).EQ.'//' .AND.
     1          IPOINT.LE.LINE-2 .AND.
     2          .NOT. VER)
     3       WRITE(IUNITO, '('' +++ Comment: '',A)') TEXT(IPOINT+2:LINE)
         ENDIF
      ENDIF
      GOTO 30
C EOF exit - set EOFL and return CHAR(0)                               *
   20 EOFL = .TRUE.
      C = CHAR(0)
C Copy character into appropriate type of variable, set END and return *
   30 IF (IENTRY.EQ.1) ICH = ICHAR(C)
      IF (IENTRY.EQ.2) THEN
         ENDL = EOL
         CH = C
      ENDIF
      ENDF = EOFL
      RETURN
C***********************************************************************
C Reset input and verification streams. If input is reset to itself and*
C was at EOF, assume that the system has reopened it, REWIND was issued*
C or something of the sort.                                            *
C***********************************************************************
      ENTRY IOUNIT (IIN, IOUT)
      IF (IIN.NE.0 .AND. (IIN.NE.IUNITI .OR. EOFL)) THEN
         IUNITI = IIN
         EOFL = .FALSE.
         EOL = .TRUE.
      ENDIF
      IF (IOUT.NE.0) IUNITO = IOUT
      RETURN
C***********************************************************************
C Backspace the buffer. This may be repeated until the beginning of the*
C line.                                                                *
C***********************************************************************
      ENTRY BACKSP
      IF (IPOINT.GT.0) IPOINT = IPOINT-1
      EOL = .FALSE.
      RETURN
C***********************************************************************
C Verify the buffer contents and its pointer                           *
C***********************************************************************
      ENTRY WRBUFF
      WRITE (IUNITO, '(''0===> '',A)') TEXT
      IFLAG  = ' '
      IP1 = MAX(IPOINT, 1)
      IP2 = MIN(IPOINT+2, LINE+2)
      IFLAG(IP1:IP2) = '***'
      WRITE(IUNITO, '('' ===>'',A/1X)') IFLAG
      RETURN
C***********************************************************************
C Flush the buffer - necessary if anything else has read the input     *
C stream.                                                              *
C***********************************************************************
      ENTRY READLN
      EOL = .TRUE.
      IPOINT = 0
      RETURN
C***********************************************************************
C Switch the verification flag                                         *
C***********************************************************************
      ENTRY VERIFY
      VER = .NOT. VER
      RETURN
C***********************************************************************
C Test for end of line                                                 *
C***********************************************************************
      ENTRY EOLN(E)
      E = EOL
      RETURN
C***********************************************************************
C Test for end of file                                                 *
C***********************************************************************
      ENTRY EOF(E)
      E = EOFL

      END SUBROUTINE RDCHAR
C***********************************************************************
C Read a list of numbers in free format. The list is a sequence of     *
C elements which are each:                                             *
C (a) a number                                                         *
C (b) FROM number TO number STEP number                                *
C or  FROM number STEP number TO number                                *
C - where FROM may be omitted, STEP may be replaced by BY.             *
C                                                                      *
C The arrays D, S, I are of dimension LEN;                             *
C iff SHORT is .TRUE. form (b) above is permitted.                     *
C On exit NUM is the number of elements of the array which have been   *
C read.                                                                *
C IRET is:                                                             *
C 0 if the list terminated with an unknown keyword                     *
C 1 if the list terminated at EOF                                      *
C 2 if there were too many numbers in the list after expansion         *
C 3 if a corrupted number was found                                    *
C 4 if an element of type (b) is malformed                             *
C If an error occurs the rest of the list is skipped                   *
C***********************************************************************
      SUBROUTINE RDDLST(D, LEN, NUM, IRET, SHORT)
      DOUBLEPRECISION D(LEN)
      REAL S(LEN)
      INTEGER I(LEN)
      DOUBLEPRECISION NUMBER, VALUE, FROM, TO, BY, LASTN
      CHARACTER * 4 WORD, OWORD
      LOGICAL SHORT
      IENTRY = 1
      GOTO 10
      ENTRY RDSLST (S, LEN, NUM, IRET, SHORT)
      IENTRY = 2
      GOTO 10
      ENTRY RDILST (I, LEN, NUM, IRET, SHORT)
      IENTRY = 3
10    IRET = 0
      NUM = 0
C Repeat...                                                            *
20    CALL READDP(NUMBER, IERR)
      IF (IERR.EQ.2) GOTO 50
      IF (IERR.EQ.0) THEN
C A simple number                                                      *
         IF(NUM.GE.LEN) GOTO 40
         NUM = NUM + 1
         IF (IENTRY.EQ.1) D(NUM) = NUMBER
         IF (IENTRY.EQ.2) S(NUM) = NUMBER
         IF (IENTRY.EQ.3) I(NUM) = NINT(NUMBER)
         LASTN = NUMBER
      ELSE
C A word:                                                              *
         IF (.NOT.SHORT) RETURN
         CALL WORDN(WORD, IERR)
C EOF?                                                                 *
         IF (IERR.EQ.2) THEN
            IRET = 1
            RETURN
         ENDIF
C One of ours?                                                         *
         IF (INDEX('.FROM.BY  .TO  .STEP','.'//WORD).EQ.0) THEN
            CALL UNREAD
            RETURN
         ENDIF
C Followed by a value                                                  *
         CALL READDP(NUMBER, IERR)
         IF (IERR.EQ.1) GOTO 60
         IF (IERR.EQ.2) GOTO 50
C FROM was given                                                       *
         IF (WORD.EQ.'FROM') THEN
            FROM = NUMBER
            CALL WORDN(WORD, IERR)
            IF (WORD.EQ.'STEP') WORD = 'BY  '
            IF (IERR.NE.0) GOTO 60
            CALL READDP(NUMBER, IERR)
            IF (IERR.NE.0) GOTO 50
         ELSE
C FROM wasn't given - the previous value LASTN was its value           *
            IF (NUM.EQ.0) GOTO 60
            FROM = LASTN
            NUM = NUM - 1
         ENDIF
C Was this BY or TO?                                                   *
         OWORD = WORD
         TO = NUMBER
         BY = NUMBER
C Next word should be the other                                        *
         CALL WORDN(WORD, IERR)
         IF (WORD.EQ.'STEP') WORD = 'BY  '
         IF (IERR.NE.0 .OR. WORD.EQ.OWORD .OR.
     1         INDEX('.TO  .BY  ','.'//WORD).EQ.0) GOTO 60
C ... followed by a number                                             *
         CALL READDP(NUMBER, IERR)
         IF (IERR.NE.0) GOTO 50
         IF (WORD.EQ.'TO  ') TO = NUMBER
         IF (WORD.EQ.'STEP') BY = NUMBER
C Loop, setting the array                                              *
         IF (BY.EQ.0.0D0) GOTO 60
         DO 30 VALUE = FROM, TO, BY
            IF (NUM.GE.LEN) GOTO 40
            NUM = NUM + 1
            IF (IENTRY.EQ.1) D(NUM) = VALUE
            IF (IENTRY.EQ.2) S(NUM) = VALUE
            IF (IENTRY.EQ.3) I(NUM) = NINT(VALUE)
30          CONTINUE
         LASTN = TO
      ENDIF
C Return for next item                                                 *
      GOTO 20
C Array full                                                           *
40    IRET = 2
      GOTO 70
C Corrupted number                                                     *
50    IRET = 3
      GOTO 70
C Error in loop specification                                          *
60    IRET = 4
C Flush the rest of the list                                           *
C Stop on EOF or an unrecognised word                                  *
70    CALL READDP(NUMBER, IERR)
      IF (IERR.EQ.1) THEN
         IF (.NOT.SHORT) RETURN
         CALL WORDN(WORD, IERR)
         IF (IERR.EQ.2) RETURN
         IF (INDEX('.FROM.TO  .BY  .STEP','.'//WORD).EQ.0) THEN
            CALL UNREAD
            RETURN
         ENDIF
      ENDIF
      GOTO 70

      END SUBROUTINE RDDLST

